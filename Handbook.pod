use utf8;

# author: kvorg / Jan Jona Javoršek
# title: Mojolicios Handbook
# comments, bugs and fixes to: jan.javorsek@guest.arnes.si
#
# (C) 2010 Jan Jona Javoršek, all rights reserved with the following exception:
#
# All material in this document can be reused in the scope of Mojo/Mojolicious
# documentation under the same conditions that apply to that package.
#
# DOC TODO:
# * CA parts of URL for docs
# * lib/Mojo/Message.pm: $message    = $message->default_charset('UTF-8');
#   Default charset used for form data parsing.
#  How do we use this?
# add http://d.hatena.ne.jp/yukikimoto/20100220/1266588242
# credit to su-bzero

=head1 NAME

Mojo and Mojolicious Handbook

=head1 ABOUT HANDBOOK

This is an alternative, temporary documentation resource for
L<Mojolicious>, a fast and light stand-alone perl
Model-View-Controller framework. It is meant as a temporary stand-in
and resource for L<Mojolicious::Guides> - Mojolicious Guide To The Galaxy.

A MVC web framework provides application interfaces for web server and
client interaction, content generation services and data models. Its
design is centered on the concept of B<separation of concerns>, making
it easy to deal with the data, the logic and the presentation
separately instead of mixing data, code and web page bits into an
indigestible soup.

To summarize the mission of L<Mojolicious> as a modern perl MVC web
framework, it is best to start with a quote from Sebastiean Riedel,
the author of Mojo and Mojolicious:

=over

Back in the early days of the web there was this wonderful Perl library
called L<CGI>, many people only learned Perl because of it. [...]
L<Mojolicious> is a new attempt at implementing this idea using state of the
art technology.

=back

L<Mojolicious> is not only a fast and light alternative but
full-featured web MVC frameworks, it offers a "lite" mode that makes
developing web tools and replacing existing CGI scripts a breeze.

It is as simple (or simpler) to deploy as C<CGI.pm> and has no
out-of-perl-core dependencies but can use certain features provided by
add-on modules from CPAN if they are install. It also offers
B<scaffolding> (generation of application files from templates) to
make starting a new project even easier.

L<Mojolicious> can be deployed as a stand-alone server, C<CGI> or
C<FCGI> application, Apache C<mod_perl> handler, a L<PSGI> application
etc., and it offers support for all the basic elements of modern
dynamic web programming: serving of B<static files>, dispatching
requests from an URL to a B<controller> (application class) and
B<action> (application method) using B<routes> and building responses
with an advanced built-in B<templating system> (or any other
templating system of your choice).

=head1 FIRST STEPS

=head2 Installation

You should install the Mojolicious framework and use the supplied
documentation and commands to learn and experiment while reading this
handbook. You can use the last release on CPAN:

   $ sudo cpanp install Mojolicious

If you want to use the latest version, however, installing from the
source repository is better:

   $ git clone git://github.com/kraih/mojo.git
   $ cd mojo
   $ perl Makefile.PL
   $ make && make test && sudo make install

=head2 First Run

You can try out the framework by modifying the example application
provided by the C<generate> command. Simply type this on the command line:

   $ mojolicious generate lite_app ml_test
   $ ./mltest daemon --reload
   $ <web-broser-of-choce> http://localhost:3000/
   $ <edit code and reload page, server auto-reloads when you save chages>

When you are ready to look at a full application, you can extract the
components of the script with the C<inflate> command or start a new
project with full-blown scaffolding and interace:

   $ ./mltest inflate

or

    $ mojolicious generate app MyTest
    $ cd MyTest
    $ ./script/mytest daemon --reload

=head2 Keeping Up To Date

L<Mojolicious> is currently (2010) under rapid development, so you want to keep with the action and update your installation and your application.

If you are using CPAN, this should update you to the last CPAN release:

   $ sudo cpanp install Mojolicious

If you installed from GitHub, this is a quick way to update:

   $ cd <path-to>/mojo
   $ git pull
   $ make clean
   $ perl Makefile.PL
   $ make && make test && sudo make install

(If you have deleted the clone of the repository, simply repeat the
installation procedure.)

Read ahead for more ...


=head1 A NOTE ON DOCUMENTATION

While using the Mojolicious documentation, it is worth keeping in mind
the following facts:

=over 4

=item *

Most of the manual pages in the distribution are reference-only: they
do not describe the framework and how to use it, but the interfaces
(APIs) and implementation details for developers. They are for people
who can follow the code. Notable exceptions are L<Mojolicious::Lite>,
which includes a tutorial, and L<Mojolicious:Guides>, the end-user
documentation, which is quite usable at this time (2010), but still
being written.

=item *

Using concise style, arguments and return values are implied
in the example provided:

    my $encoding = $renderer->encoding;
    $renderer    = $renderer->encoding('koi8-r');

This example means that calling the C<encoding> method on a renderer
object with no arguments will return the current encoding, but with an
argument will set the value and return the renderer again.

In fact, this is the usual method interface in Mojolicious since it
allows chaining method calls on the object and avoids returning a
value you should probably already have. If you want the traditional
approach where a set method returns the value set, you can always do:

    my $encoding = $renderer->encoding('koi8-r')->encoding;

=item *

See also Mojolicious on CPAN
(L<http://search.cpan.org/~kraih/Mojolicious/>), Mojolicious home at
L<http://www.mojolicious.org/> and Sebastian Riedel's site at
L<http://labs.kraih.com/>.

There are also presentation slides in English by Anatoly Sharifulin
L<http://www.slideshare.net/sharifulin/mojolicious-the-web-in-a-box>.


=item *

You should look at some end user documentation and essential reference
in C<Mojolicious> distribution:

=over 8

=item L<Mojolicious::Lite>

Introduction to the simplified application interfaces with full examples.

=item L<Mojolicious::Guides>

The end-user documentation. See L<Mojolicious::Guides::Routing> for
documentation and examples for the use of L<Mojolicious> and
L<L<Mojolicious::Lite> routing, see L<Mojolicious::Guides::Rendering>
for rendering and templating documentation and
examples. L<Mojolicious::Guides::Cookbook> contains many recipies,
manly for deplayment in different environments, and is a must if you
want to be ready to deploy your application. See
L<Mojolicious::Guides::Cheatsheet> for a concise reference on reserved
stash values and environement variables used by the framework.

=item L<Mojolicious::Commands>

Command-line interface, but command-line commands also give help by
appending a 'help' to the commandline.

=item L<Mojo::Template>, L<Mojolicious::Plugin::EpRenderer>

Templating subsystem, see L<Mojolicious::Guides::Rendering> first.

=item L<MojoX::Routes>

See SYNOPSIS for examples and syntax after reading
L<Mojolicious::Guides::Routing>.

=back

=item *

It is well worth to read and understand the reference manual page of
L<Mojo::Base>, the base class for Mojo/Mojolicious projects that
provides the general C<new> method and highly optimized attributes for
Mojo objects, and L<Mojo::ByteStream> with its versatile portable text
and bytestream manipulation functions and the simplified C<b()> syntax.

=item *

Full examples, blogs and other resources:

=for comment
XXX needs non-vti examples ;-)


=over 8

=item Bootylicious

A one-file blog engine on L<Mojolicious>: L<http://getbootylicious.org/>

=item Showmetheco.de blog

C<vti>'s blog: L<http://vti.showmetheco.de/>

=item Pastelicious

A simple nopaste service build as a C<Mojolicious::Lite> application:
L<http://showmetheco.de/>

=item v6test

A IPv6 stack testing application with a NoSQL back-end (quite
heavy-weight, using KiokuDB, an object-graph store engine built on
Moose, to access mongoDB): L<http://www.v6test.develooper.com/couch>

=for comment
add luzy, ssh, irc

=back

=back

=head1 OVERVIEW OF MOJOLICIOUS AND ITS ARCHITECTURE

L<Mojolicious> is composed of a full HTTP 1.1 Client/Server framework
and basic application framework building functionality in the C<Mojo>
namespace, a number of advanced services that compose the core of
C<Mojolicious> framework in C<MojoX> namespace and the framework
itself with its default and "lite" bindings in C<Mojolicious> namespace.

The presentation here is very simplified and presented from the point
of view of the application programmer, with as little detail on the
server/implementation side as possible. See L<COMPONENTS OF
MOJOLICIOUS> for a more detailed description.

The HTTP Server is the starting point of the application. For each
HTTP request, it creates a L<Mojo::Transaction> object, usually
referred to as C<tx>, with two L<Mojo::Message> objects as attributes
C<req> and C<res>, for request and response. The two objects
encapsulate the whole complexity of HTTP requests, including headers,
contents with their MIME types and encodings, upload files, body
(POST) and path (REST) parameters, cookies etc.

When the request part of the transaction is processed sufficiently,
the server calls the transaction handler method of the application
(called simply C<handler>). The application is now free to process the
request and build a suitable response, for example a web page, an
error code or a redirect. This is a flexible base on top of which any
web framework can be built, and L<Mojolicious> is one such framework
built on top of L<Mojo> HTTP 1.1 stack and a number of L<MojoX> extensions.

A L<Mojolicious> application essentially subclasses L<Mojolicious>,
providing setup code in the method C<startup> to be called once at
startup of every application instance, while most of the L<Mojolicious>
functionality and defaults (default controllers, MIME type database)
is set up in the object creation method C<new> and can be accessed via
the application object.

The start script sets the application namespace (in C<$ENV{MOJO_APP}>)
and passes control to the server, which in turn calls the C<handle>
method for every successfully constructed transaction request and
processes the transaction in the following steps:

=over 4

=item *

load session, if there is one

=item *

run the application's static dispatcher, by default for C<public/>

=item *

run the application's routes dispatcher, using routes set up in C<setup()>

=over 8

=item *

[by dispatcher] run the application's controller::action, if found by routes dispatcher

=item *

[by controller] perform application logic, setting values in C<$stash>

=item *

[by controller] call render(), using renderer, stash and templates to
construct the response

=back

=item *

process errors and not-found states

=item *

store session state

=back

The routes dispatcher is where most of the application is connected:
the dispatcher will find the best match for request URI and select a
controller and an action (a class and a method in your application.

In the case of example application as produced by C<generate app>

 $r->route('/:controller/:action/:id')->to('example#welcome', id => 1)

calls

 <app_name>::Example->welcome()

The path data and additional context are all stored in C<$stash>, a
hash used for transaction-specific non persistent data storage and
exchange, and made accessible to your application controller to
performs whatever functions needed and store more data on the stash.

It is your controller's job to implement any connections with external
data sources (the "model" from MVC paradigm). If you need any start-up
initialization, you can perform it in the application's C<startup()>
method.

The last stage in the pipeline is to convey the results back to the
HTTP stash: the process is called rendering. Your controller can
render directly, using either C<render_text()> or C<render_data>
(where the MIME type has to be set XXX), but most often the built-in
renderer L<MojoX::Renderer> will be used and data will be passed to it
using the stash.

The renderer by default tries to use a template called C<<
<controller>/<action> >>, so C<< <example/welcome> >> in this
case. The file has two extensions: the first is the format of the
result (ie. C<html>), and will be used to select the correct
MIME-type, while the second is the format of the template (by default
C<.ep>). The format extensions is processed by looking up a list of
"handlers", usually provided by plugins, and by default including
C<.txt>, C<.ep>, C<.epl>, C<.json> and C<.pod>.

Most of the time, the layout is in the Mojoliciuos built-in C<.ep>
format, which is small, fast and versatile, but fully described
L<RENDERERS AND TEMPLATES>. It has many features, including helpers
that can provide additional services, such as translation.

After the renderer is finished, the control is passed back to the HTTP
stack and it serves the response to the client.

Complicated? It looks much simpler when you are writing an
application, since all of this complexity is abstracted away and
safely kept behind defaults. All you need to do is set up your routes
and write your controllers/actions, models and views (templates).

=head1 MOJOLICIOUS AND MOJOLICIOUS LITE

=for comment
XXX perhaps a short anatomy of the file structure here

=head1 DISPATCHING

Dispatching is the process of mapping the HTTP request to a specific
action an executing that action to satisfy the request. This can be
achieved simply by finding and serving the correct file - what we call
B<static dispatching> - or by finding and calling the correct method
in the application.

In L<Mojolicious>, the two approaches are implemented as B<static> and
B<routes dispatcher> and the framework in fact attempts a static
dispatch for each request, only trying a routes dispatch if it cannot
satisfy the reqeuest simply with a file.

=head2 Dispatching Static Files

C<MojoX::Dispatcher::Static>

=for comment
XXXX mostly not done from here on, but there are some fuller sections
to be found.

=begin consideration

(03:38:40 PM) doubi: I have my mojolicious app in a subdirectory, but it keeps looking for static things like css and js under the top level site folder. How can I make it look in the subdir, where app is?
(03:50:24 PM) sri: doubi: you can set $app->static->prefix
(04:15:06 PM) doubi: sri: Where should $app->static->prefix be set? In individual controllers?
(04:16:16 PM) sri: doubi: startup
(04:39:22 PM) sri: umm...prefix is the prefix used for request paths not a file system path
(04:40:02 PM) sri: app->static->root is the filesystem path

on multiple static roots:
(11:51:47 PM) vti: but you can always add you own dispatcher
(11:51:59 PM) vti: and even rewrite dispatch process

<stephen> Basically, I'd like to stream a file to output, rather than having to pull it into memory and use $self->render_text().
<sri> trivial with Mojo::Asset::File
<stephen> How do I use that with a controller? Right now I'm using File::Slurp and $self->render_text() on the results.
<sri> or actually just ->render_static('/foo.txt');
<sri> we already have a sugar layer for it

<jeff> is there a way to set where to look for "public" in a mojo app?  I've basically got the app running on a subdomain, but it's not finding stylesheets, javascript, etc.
<jeff> either in the app itself... or ideally as an Apache directive/environment variable
<sri> jeff: public should just work
<sri> of course under the same base path
<sri> $app->static->root is the file system path
<jeff> may I post 10 lines of apache config here
<vti> jeff: http://showmetheco.de/ :)
<garfield> [ Paste ]
<jeff> http://showmetheco.de/ca9032597d93bad7efcf5fe00e423ed15d5ecd47
>>

    <Perl>
      use lib '/home/jhorn/mojo/elite_signup/lib';
      use Apache2::Mojo;
      use EliteSignup;
    </Perl>

  <Location /signup/>
    SetHandler perl-script
    PerlHandler Apache2::Mojo
    PerlSetEnv MOJO_APP EliteSignup
    PerlSetEnv MOJO_RELOAD 1
  </Location>
<<
<jeff> now... will this app just know where to look for public
<jeff> or do I need to set something
<jeff> public is currently in /home/jhorn/mojo/elite_signup/public
<sri> oh mod_perl, i have no clue about that
<sri> jeff: my guess is that it would detect it
<sri> all static files should be available under /signup/*

=end consideration


=head2 Dispatching with Routes

=head2 Basic Routes

=begin consideration

When using redirect_to with named routes... is there a way to set values for the placeholders in that route?
(03:07:35 PM) sri: memowe: redirect_to('name', foo => 'bar');

<jeff> I need to run a Mojo application in a subdomain... i.e. http://www.foo.com/xyz/ should be running the mojo app, but http://www.foo.com/anythingelse shoud not ... does anyone have an example Apache config and necessary changes to the app to make this work
<sri> why would you have to change your spp?
<jeff> not sure if the pattern for /:controller/:action/:id would change because the app is relocated
<sri> it should be able to detect the base part of the path
<sri> and then only use the dynamic part for routes
<jeff> ok cool

 xantus: I never use trailing slashes in my routes (not sure if that matters, but I'd check that)

=end consideration

=head2 Advanced Capturing

=head2 Bridges

=head2 Routes and under in L<Mojolicious::Lite>

Automation, controller/methods

Ladders

=head2 Dispatching Without Routes

Existing dispatchers, writing your own dispatcher


=head1 CONTROLLERS AND ACTIONS

XXX This should contain user documentation on controller and action
writing, and simple rendering (C<render_text()>, C<render_data()>),
except more complicated things, such as models.

Forget-me-not: stash, parameters

=begin consideration

14:59	maettu	some days you explained me where / how to find the parameters of a GET request. Now where are the parameters of a POST? :-S
14:59	sri	$self->params
15:04	sri	if you want only POST parameters use $self-req->body_params
15:13	maettu	:-S
15:19		ok, found it: $self->req->content->asset
15:20		perhaps this helps you to understand what I meant.. :-)
15:20	sri	so you want the actual message body unparsed
15:20		$self->req->body will work too

=end consideration

C<< ->url_for() >> and C<< ->redirect_to() >>

Details, gotchas

Implementing stuff on that


=head1 RENDERERS AND TEMPLATES

XXX This should contain user documentation on rendering with .ep and .epl, statsh interaction, mime types for layouts and results, helpers and handlers, additional renderes etc.

=head2 Rendering in Mojolicious

=begin consideration

(02:09:16 AM) ask: what's the proper way to render a bit of data with Mojo::Template but not return the results to the browser?
(02:10:00 AM) ask: (I want to render a template snippet and then return it as part of a JSON data structure)
(02:10:11 AM) sri: ask: ->render_partial('some_template')
(02:11:00 AM) sri: or ->render_*(..., partial => 1);
(02:11:19 AM) sri: it will just return the result
(02:12:03 AM) ask: sri: ah, of course - thanks.

=end consideration

render_text() for binary data

=head2 Rendering Plugins

=head2 Handlers

=head2 Templates in Mojolicious

=begin consideration

(01:50:51 AM) stephen: Hello all-- today on "Stephen doesn't get it", if I add_helper( 'foo' => sub { #whatever }) and load the plugin, can I then do <%= foo %> in an epl template?
(02:12:14 AM) sri: stephen: not epl, just ep
(02:21:13 AM) stephen: sri: OK, so in epl I have to look up the helper and call it?
(02:21:18 AM) sri: maybe we shouldn't report them, but i hate to ignore events
(02:21:28 AM) sri: stephen: yes
(02:21:34 AM) sri: stephen: why not use ep?
(02:22:11 AM) stephen: sri: I'll try ep. For some reason I started out doing all my templates in epl.
(02:22:40 AM) sri: ep is really way better
(02:27:44 AM) stephen: Where's the best place to learn about ep?
(02:28:57 AM) sri: just the tutorial i think
(02:29:25 AM) sri: it's not hard, there are helpers, stash vars get initialized as $foo and the like and $self is already initialized
(02:29:29 AM) sri: thats it basically
(02:29:34 AM) stephen: OK
(02:29:50 AM) sri: and auto escaping is on

(11:40:07 AM) rindolf: Hi all. <%= $register_form %> HTML-escapes the string. How can I insert a raw string without escaping?
(11:40:51 AM) yko left the room (quit: ).
(11:42:48 AM) rindolf: sri: do you have any idea?
(11:46:49 AM) rindolf: http://search.cpan.org/~kraih/Mojolicious-0.999922/lib/Mojolicious.pm - where is ->render documented?
(11:46:51 AM) marcus: rindolf: <%==
(11:47:54 AM) lee7: Mojo::Template says <%== Perl expression, replaced with XML escaped result %>
(11:48:05 AM) ***lee7 scratches his ugly head
(11:58:14 AM) marcus: lee7: that's wrong. Thanks for pointing that out
(11:58:17 AM) marcus: sri should fix it
(11:58:28 AM) lee7: <%= does not html-escape contents, <%== escapes it. maybe  $register_form got escaped before?
(11:58:37 AM) marcus: lee7: the docs are wrong
(11:58:44 AM) marcus: sri switched it to escape by default
(11:58:53 AM) lee7: hah!
(12:03:41 PM) sri: marcus: the docs are right, it's just a difference between .ep and .epl
(12:21:28 PM) sri: updated pod to make it more obvious

=end consideration

=head2 Extending templates: Helpers

=head2 Using other templating engines


=head1 SESSIONS, COOKIES, AUTHENTICATION, AUTHORIZATION

=begin consideration

<vti> sri: how to disable cookie savings in mojo::client?
<sri> vti: set cookie_jar to undef

sessions and performance: avoiding model access (DB or file) on every
page read by using memcache ... http://www.youtube.com/watch?v=i6Fr65PFqfk - signed
cookies and crucial data in the cookie and you are done

<und3f> How to clean session?
<und3f> Witch one build on signed cookies 
<und3f> $self->session 
<xantus> $self->stash->{session} = {};
<xantus> or better, $self->stash( session => {} );
<und3f> thanks 
<sri> expires => 1 should work too
<und3f> yesterday i tries expires => 0 :P

=end consideration

=head1 WORKING WITH FILES

XXX using files from controllers or renderers, not static dispatching

uploads

as data, dispatching is covered in a previous section!

mime types

encodings

issues with locking and updating


=head1 USING MODELS

Mojolicious is not designed with any particular data model in
mind. Perl currently has a number of ORM (object-relational-mapping)
implementations, ie. L<DBIx::Class>, L<Class::DBI>,
L<Rose::DB::Object>, L<ObjectDB>, and you can use other kinds of
models, such as L<DB::CouchDB>, tied variables, flat file
storage/retrieval etc.

Without setting any preference or precedence, we will use
L<DBIx::Class> with a C<SQLite> for backend to present working
examples.

In a MVC implementation, the usual structure of the application
isolates the three components as much as possible to ensure separation
of concerns (ie. clean interfaces) and to make it easier to change one
component of the application. In addition, most models based on
existing ORM layers make changing the backend implementation (the
database used) very simple, providing even more flexibility to your
application.

The B<controller> is what the majority of the L<Mojolicious> framework
is all about - routing the data from the model (any data source you
need) to the view (usually using a templating system). The cleanest
way to achieve this is to use the model in the controller and export
the data to the templating system via the stash.

If you find yourself accessing the model directly from the
templating system, you will end up with ugly templates and complicated
accident-prone application. The stash is your friend, use the stash!

=head2 Example: The Records Database

=head2 Authentication/Authorization, Session and Model

=head2 Adding CRUD (Create, Update, Delete)

=head2 Models and files


=head1 TESTING AND DEBUGGING MOJOLICIOUS APPLICATIONS

writing tests

basics: warnings, strict, perltidy, note on L<Mojolicious::Lite>
defaults

controlling verbosity

log levels


=head1 MOJOLICOIUS PLUGINS

Explanation of plugin architecture and interception points.

=head2 Standard Default Plugins

=head2 Optional Default Plugins

=head2 Finding Additional Plugins

=head2 Writing Your Own

Extending Mojolicious for your application is often best achieved by
writing a plugin and loading it in your application. See L</Extending
Mojolicious with Plugins> for more information.

=head1 USING MOJO HTTP CLIENT

in an application

with -Mojo

using Mojo::DOM

=head1 MOJOLICIOUS IN PRODUCTION

XXX Introductions

=head2 Securing a stable environment

When preparing a project for release into production, you should make
sure it is stable and functional to avoid disappointing users and
causing unnecessary mainteinance overhead.

You should prepare a set of test to make sure the application is
acutally working in it current environment as expected.

To make sure the environment remains stable, you should install
L<Mojolicious> directly in its working environment:

  $ cd <mojolicious-source-distro>
  $ perl Makefile.PL PREFIX=<app-deployment-dir>/lib
  $ make test && make install

The C<@INC> handling is now managed by the same mechanism that finds your application files.

XXX check if this actually works order-wise

B<XXX Kind souls will supplement this with advice on running
effectively under different environments.>

=head2 Running a stand-alone server

getting set-up with an asynchronous C<poll()>

Issues with blocking database connections: XXX discussion on IRC, no
definitive argument and explanation receive.

prefork

=head2 Pre-forking behind a proxy

=head2 Running with C<CGI>

=head2 Running with C<FastCGI>

=head2 Running with C<PSGI>

=head2 Running under C<mod_perl> with C<PSGI> 

=begin comments

Deploying bootylicious under Apache with Fast CGI:
http://getbootylicious.org/articles/2009/09/apache-fastcgi.html

<sri> i'm just guessing though, Apache2::Mojo has historically never been that great
<jeff> how do people typically run Mojo in production?
<sri> mostly fastcgi
<sri> like catalyst
<sri> i think nginx with Mojo::Server::FCGI is the most popular setup atm
<sri> (for performance)
<sri> if you want easy setup Apache + Mojo::Server::FastCGI should be the best choice


<jeff> ok... thanks
<jeff> how can I get what is being matched against the routes... my forms are posting to relative urls (e.g. action="foo") and the "foo" action is not being called
<jeff> I have routes that look like $r->route('/:action/')->to(controller => 'signup')
<jeff> but Signup::foo isn't being called for the /signup/foo action
<jeff> I cannot seem to use routes that look like /:controller/:action/ because then it thinks what is the action is the controller
<jeff> since I'm just running the app in /signup via the apache config... I don't think route is matching the /signup part at all
<jeff> I think it's thinging /signup is /
<jeff> and /signup/foo is /foo
<jeff> but I'm not sure
<sri> thats correct, /signup is the base
<sri> and not matched at all
<sri> thats what keeps the application portable
<jeff> so $r->route('/:action/')->to( controller => 'signup') should work in this case?
<sri> yes
<sri> you can dump $self->req->url
<sri> base should be /signup and real path /foo
* stephan48 has quit (Ping timeout: 360 seconds)
<sri> if thats not the case it might be a Apache2::Mojo bug
<jeff> do you have any pointers to doing an Apache + fastCGI setup besides the CPAN page
<jeff> I've run into a number of problems with this module so far
<jeff> yep... when I print $self->req->url, I get "/" even though I'm doing /signup/foo
<jeff> actually... using Dumper... I see base pointing to /signup, but path has 'parts' => []
<jeff> yikes... I just updated Mojo and Apache2::Mojo from CPAN... now I'm getting "Can't locate object method "load build" via package "Mojo::Loader" at ..../Apache2/Mojo.pm line 36"
<sri> your version of Apache2::Mojo is ancient
<jeff> latest from CPAN
<jeff> shall I get it elsewhere
<sri> that sucks, the bugfix has been around for like a year
<sri> prolly some github repo then
<sri> Mojo::Server::FCGI should have example configs in the examples directory
<sri> those work with fcgi and fastcgi
<jeff> so if I set that up... I really only need to:
<jeff> Alias /signup /path/to/my/signup and I'm good
* sri nods
<jeff> ok... that sounds much better
<jeff> Uwe's source on github is version 0.004 which is the one I have btw
<jeff> if anyone knows a newer one that'd be great as well... but I'm going to crank on using fcgi instead since that seems more stable
<jeff> there's no $VERSION defined in the file (of Apache2::Mojo)
<jeff> I had it sent to me in January
<jeff> file name is tewk-apache2-mojo-2ad4431
<jeff> the dist.ini says it's 0.004 as well
<jeff> but I don't think it was packaged up for CPAN yet
<jeff> anyhow... after upgrading Mojolicious from CPAN, I actually get a different error (above) even with this newer Apache2::Mojo

03:25:37 AM) doubi: Evening all. I'm playing with bootylicious to try to understand mojolicious better. I first set up fine following http://getbootylicious.org/articles/2009/08/ideal-for-shared-hosting.html .
(03:25:39 AM) garfield: [ Ideal for shared hosting / Bootylicious ]
(03:25:40 AM) garfield: http://xrl.us/bgwwt4
(03:26:14 AM) doubi: Now I'm trying to see if I can move it to a subfolder of my site, so that everything will be served from mysite.com/booty/ or somesuch. How do I get the menu items to point to pages under /booty/ and not under mysite.com/ ? I tried changing "base" in bootylicious.conf but it made no difference
(03:26:43 AM) sri: stop right there
(03:26:58 AM) sri: you should not have to change anything in the app
(03:27:10 AM) sri: you just change the apache config
(03:27:33 AM) doubi: ... ok... brb...
(03:27:48 AM) sri: different scriptalias might be enough
(03:28:30 AM) sri: thats why we have helpers like url_for, they generate all our urls dynamically based on the incoming request data
(03:29:30 AM) sri: doubi: vti also demonstartes how to use mod_rewrite for that
(03:30:11 AM) sri: you should be able to rewrite to /booty/ instead of just /
(03:30:47 AM) sri: but this all has nothing to do with mojolicious, stay away from the app :)
(03:34:12 AM) sri: vti++ # that article is really good
(03:34:39 AM) sri: vti should repost them on his blog imo
(03:41:08 AM) doubi: *sigh* I think this might all be a lot more complex than it should because I'm on only on virtual private hosting and can't examine / change my httpd.conf
(03:43:23 AM) doubi: I think the clincher is my inability to set DocumentRoot
(03:45:42 AM) doubi: In the example it's set to site.com/htdocs, which I can't copy. I'd have though that means I have to work round it with static->prefix or static->root like you said before sri?
(03:48:00 AM) sri: that of course changes everything
(03:48:12 AM) sri: you can use prefix
(03:48:30 AM) sri: prefix('/booty')
(03:49:54 AM) sri: you might want to prefix all your routes with a bridge for less typing too
(03:50:23 AM) sri: my $b = $r->bridge('/booty'); $b->route(...)->to(...); and so on
(03:58:56 AM) sri: that you are allowed to use mod_perl but not to configure apache properly seems weird though
(04:02:38 AM) doubi: There's no mod_perl actually, but both mod_fastcgi and mod_fcgid
=head2 Mojo[licious?] Modes

(12:11:45 AM) sri: each mode can have a method in the app class
(12:11:52 AM) sri: like production_mode
(12:11:58 AM) sri: development_mode
(12:12:05 AM) sri: that gets called on startup
(12:12:20 AM) sri: and they can configure the app for that specific environment
(12:12:39 AM) sri: like different databases for development and production ;)
(12:13:23 AM) sri: it's like a environment specific startup method
(12:14:17 AM) sri: thats it basically
(12:14:52 AM) sri: each mode also gets it's own log file and the like but thats not so important

(12:12:55 AM) Igneous: just curious.. what webservers are people in here using mojolicious with? anyone using it with nginx w/embedded perl?
(12:13:18 AM) sri: nginx/fcgi mostly i think
(12:13:30 AM) sri: not seen nginx/embedded perl yet
(12:13:51 AM) vti: sri: i've written it ages ago, just haven't released :(
(12:13:57 AM) und3f left the room (quit: Quit: Bye).
(12:14:05 AM) Igneous: sri: that's dandy, thanks
(12:14:45 AM) vti: there were some ugly warnings afair
(12:14:50 AM) sri: Igneous: nginx and mojolicious daemon should be good too
(12:15:05 AM) Igneous: a followup question.. I'm pretty new to the perl scene (though I know bash and lua).. what is the likelihood that I'll be able to pick up mojolicious while building on my non-existant perl knowledge?
(12:15:35 AM) sri: Mojolicious::Lite should be good for learning
(12:16:11 AM) sri: try the tutorial and see how far you get
(12:16:18 AM) sri: perldoc Mojolicious::Lite

(12:32:17 AM) marcus: sri: can I use Mojolicious with FCGI::Engine?
(12:37:27 AM) sri: marcus: you might just be able to use plackup with psgi auto detection :)
(12:38:01 AM) marcus: is that a good way to deploy apps?
(12:38:39 AM) sri: sure, why shouldn't it?
(12:39:03 AM) sri: it's pretty much equal to cgi and fastcgi
(12:39:07 AM) marcus: dunno, did you test it?
(12:39:32 AM) sri: i'm only testing for psgi spec compliance
(12:39:37 AM) sri: not plack
(12:39:43 AM) sri: no idea how good it is
(12:39:53 AM) sri: but if it breaks it's not my problem :D
(12:40:21 AM) marcus: well, it would be my problem
(12:40:28 AM) marcus: which is why I'm asking now
(12:41:00 AM) sri: don't think anyone has experience with fcgi engine and mojolicious
(12:41:19 AM) marcus: I use fcgi engine with iusethis
(12:41:29 AM) marcus: it's pretty cool
(12:42:21 AM) sri: don't even know how it works so i'm just guessing
(12:42:45 AM) marcus: it controls standalone fcgi serves
(12:42:47 AM) marcus: servers
(12:42:53 AM) sri: if it's psgi compliant it should be worth a shot

=end comments

=head1 COMPONENTS OF MOJOLICIOUS

This section is an overview of the implementation, with more detail
than needed for just simple application development. It is intended as
a supplement to reading the code and the reference documentation. It
might be outdated or simply wrong.

XXX Long, but unfinished ...


=head2 C<Mojo>, C<MojoX> and C<Mojolicious> namespaces

L<Mojolicious> is logically divided into three namespaces:

=over 4

=item C<Mojo>

C<Mojo> contains a web development framework, a framework for building
simple web applications and web application frameworks.

C<Mojo> implements a full web server and client stack with all the
necessary supporting infrastructure, including templates, but does not define any
dispatchers and application logic (controllers).

It is meant to serve as base to be extended by users, used for minimal
applications and use as framework for more full-blown web frameworks,
such as L<Mojolicious> itself.

=item C<MojoX>

C<MojoX> is the namespace for extensions to C<Mojo>. This is the
namespace used by user-developed extensions found on CPAN and
GitHub.

Inside the C<Mojolicious> distribution, this namespace is populated
with classes that extend C<Mojo> with sessions, dispatchers and
controllers and an implementation of the routes dispatching system.

=item C<Mojolicious>

C<Mojolicious> is the namespace of the Mojolicious web application
framework itself. It is based on C<Mojo> and sessions, dispatchers,
controllers and routes dispatching from C<MojoX>. It presents two
application interfaces, L<Mojolicious> for full blown applications
with multiple files and controller classes, using template directory
structures, and L<Mojolicious::Lite>, a simplified interface with a
single controller class where the whole application is expressed
in a single file.

=back

=head2 L<Mojo::Base>: a base class with attributes

L<Mojo::Base> is a simple base class for Mojo projects. It provides
highly optimized essential services used in other Mojo and Mojolicious
classes. Most classes in Mojolicious are based on L<Mojo::Base>.

Understanding L<Mojo::Base> and attributes is crucial for
understanding Mojolicious code, since this facility is used throughout
the framework.

L<Mojo::Base> implements two services, an object constructor and
object attribute infrastructure, expressed as two methods:

=over 4

=item C<new>

A basic object constructor. You can pass it either a hash or a hash
reference with attribute values to set up default attributes at construction.

=item C<attr>

Create attributes.  An array reference can be used to create more than
one attribute with a single call. An optional second argument that
must be either a B<constant> or a B<sub> reference can be used to set a
default value. The sub reference will be excuted at accessor read time
if there's no set value.

=back

L<Mojo::Base> is optimized for performance, since well implemented
attributes can be used throughout the framework and must be very
fast. For this reason, attribute access is optimized by compiling
custom code (a bit lispish, but very efficient). Essentially attribute
lookup turns into execution of an anonymous subroutine. If all the
contents of the subroutine are static, the access can be highly
optimized by perl runtime.

To set up attribute, call the C<att> method on the class:

  package CreditCard;
  use base 'Mojo::Base';

  __PACKAGE__->attr('holder'); #use __PACKAGE__ instead of package name
  $card->attr('good_thru');                      # declare new attribute
  $card->attr('valid_from' => '02-10');          # with default value
  $card->attr('valid_from' => sub { ... });      # executed at read time
                                                   unless overruled by setting a value
  $card->attr([ qw/type card_name/ ]);           # declare multiple
  $card->attr([ qw/type card_name/ ] => 'Visa'); # default value for all
  
  package Main;
  my $card = CreditCard->new();   #or, with defaults as a list or a has reference
  my $card = CreditCard->new(holder => 'A. N. User', type => 'Visa');
  my $card = CreditCard->new({holder => 'A. N. User', type => 'Visa'});

Note that it is not possible to add attributes to an existing object,
attributes are properties of the class. If you try to access and
attribute that has not been defined, you will get the following error:

  Can't locate object method "type" via package "CreditCard" at <filename> line <no>

In addition, since the values are not hold in a data structure but are
compiled in the code, it is not possible to dump them easily.

Setting and accessing the attributes is easy:

  $card->name('A. N. User');                    # returns $card, not value
  print 'Card holder: ' . $card->name . "\n";   # returns value
  # chaining the call
  print 'Default holder :' . $card->name('A. N. User')->name; . "\n"

=head3 Attributes and References

Since the default value for an attribute can be either a constant or a
sub reference, it is not possible to initialize an attribute to an
array or a has reference directly. You need to do it using an anonymous sub:

  package EtcPassword;
  use base 'Mojo::Base';
  
  __PACKAGE__->attr('users' => sub { [] });      # defaults to en empty array ref
  __PACKAGE__->attr('users' => sub { [ qw/jane john jules jimmy/ ] }); 
                                                 # or a populated one
  __PACKAGE__->attr('user_homes' => sub { {} }); # defaults to empty hash ref

You can set an attribute to a reference and use dereferencing
semantics to query the data:

  print join(', ', @{$p->users});      # print all element of the array
  print $p->users->[0];                # print first element
  print $p->users->[1] = 'johannes';   # set second element

Please note that the same rules does not apply when using the
constructor or the accessor, using a subroutine there stores a C<CODE>
reference, and using the value itself is perfectly legal:

  $p = EtcPassword->new;
  $p->users([ qw/jane john jules jimmy/ ]);
  # or just:
  $p = EtcPassword->new(users => [ qw/jane john jules jimmy/ ] );

=head3 Attributes and Objects

The anonymous subroutine semantics of accessor setup makes it perfect
for setting up use-relationships with other objects, since the
accessor is set up at class initialization time, but the subroutine is
only executed in the instance when the accessor is first used.

For example, this is how Mojolicious application instance sets up a
types object:

  Mojolicious.pm:
  
  __PACKAGE__->attr(types => sub { MojoX::Types->new });

At first access (but not before, so memory may be conserved if the
object is never used), a new L<MojoX::Types> instance will be created
and its reference stored in the accessor. From that point on, it can
be accessed from the application object like any other attribute,
chaining accessors and methods as you go:

  # check a type using object's method:
  $self->types->type('html');
  # change a type using object's method:
  $self->types->type(html => 'text/html; charset=utf-8');
  # get all types using an accessor:
  my $types_hashref = $self->types->types;

=head3 Subclassing Constructors

In most cases, a cubclass of L<Mojo::Base> does not need to implement
its own constructor, relying instead no the parent constructor.

If your class needs initialization, it must still call the parent
class constructor to perform attribute initialization.

The parent constructor performs blessing to your class for you, but
you need to return the reference. If you wish to retain the
constructor semantics, you should also pass the arguments to C<new()>
to the implementation in L<Mojo::Base>:

  package Something;
  use base 'Mojo::Base';
  
  __PACKAGE__->attr('name' => 'a thing');
  
  sub new {
      my $self = shift->SUPER::new(@_);   # call parent class, with arguments
      # ... init ...
      return $self;                       # return the blessed reference
  }

See L<Mojo::Base> for reference documentation and more examples.


=head2 Support classes

=begin consideration

Possibly this whole section is misguided and cumbersome ... the info
is well needed, and quite necessary to understand the code, but
perhaps it belongs into a later section or even an appendix. Please,
advise!

=end consideration

A number of L<Mojo> classes implement basic services and are not
usually needed directly in application code: L<Mojo::Asset> for
management of data and files in the HTTP implementation (also
performing file streaming without loading the whole file),
L<Mojo::Date> implementing HTTP 1.1. dates, L<Mojo::Exception> for
exception handling with context information, L<Mojo::Loader> for class
loading and plugin framework, L<Mojo::Log> for general logging,
L<Mojo::Path>, an URL path container, L<Mojo::Stateful>, an abstract
base class for state keeping objects, and many more.

Most of these classes will not be used directly by the web developer,
but will be used either by other classes or through some additional
syntactic layer (syntax sugar).

A number of classes in L<Mojo> implement generally useful services and
are often used both in the framework itself and in applications.

=head3 Mojo::ByteStream

L<Mojo::ByteStream> provides portable text and bytestream manipulation
functions, such as encoding and decoding, simple searching (C<< my
$position = $b->contains('string') >>), line-by-line reading (C<< my
$line = $b->get_line >>), quoting (including quoted printable), HTML
and XML escaping, URL escaping, URL sanitizing and stringification
(C<< my $string = $b->to_string >>).

L<Mojo::ByteStream> is a frequently-used class, so it can export its
constructor as C<b()>. This syntax sugar in combination with method
chaining facilitates the use considerably:

  use Mojo::ByteStream 'b';
  
  $value = b($value)->decode($charset)->to_string;

is the same as:

  use Mojo::ByteStream ;
  
  $bs = Mojo::ByteStream->new($value);
  $bs->decode($charset)
  $value = $bs->to_string;

See L<Mojo::ByteStream> for complete reference documentation.

=head3 Mojo::JSON

L<Mojo::JSON> is a minimalistic implementaton of RFC
4627 (L<http://www.ietf.org/rfc/rfc4627>), aka
JSON (L<http://www.json.org/>.

JSON (JavaScript Object Notation) is a lightweight data-interchange
format, supported by most JavaScript libraries and scripting
languages.  It is easy for humans and for machines. JSON is a text
format that is completely language independent but uses familiar
conventions and is much easier to parse and generate than XML, making
JSON an ideal data-interchange language for the web.

JSON is built on two structures:

A collection of name/value pairs, mapped to perl an ordered list of
values, mapped to perl arrays. L<Mojo::JSON> does not support blessed
references.

In Mojolicious, JSON is supported as an output format by the rendering
subsystem (the C<json> rendering handler, see L<MojoX::Renderer> and
as a configuration language via a plugin
(L<Mojolicious::Plugin::JsonConfig>).

If you wish to receive and parse JSON messages, ie. in an AJAX or
WebSocket context, you will need to use L<Mojo::JSON> directly in your
controller.

JSON format should look familiar enough:

       JSON             Perl

    [1, -2, 3]       [1, -2, 3]
    {"foo": "bar"}   {foo => 'bar'}

See L<Mojo::JSON> for reference documentation, JSON web
page at L<http://www.json.org/> for more info and RFC
4627 (L<http://www.ietf.org/rfc/rfc4627>) for a formal specification.


=head3 Mojo::Template

Mojo contains an efficient versatile perlish templating system,
implemented in L<Mojo::Template>. See L<Mojo::Template> for templating
reference documentation and some examples.

The templating system is used not only for web templates, but also for
services such as code/scaffolding generation and the like. Templates
get compiled into a perl function call and are very efficient.

For web applications, the templating implementation is wrapped with
additional services and functionality, implemented as a plugin:
L<Mojolicious::Plugin::EpRenderer>.

The plugin, enabled by default, registers the templating engine as the
handler for C<*.ep> (embedded perl) files (handlers explained in L</Renderer,
Handlers, Helpers, Templating engines>).

There is an older, simpler version with less fuctionality
(L<Mojolicious::Plugin::EplRenderer>, registers as handler for
C<*.epl> (embedded perl lite) files).

See L</Templates in Mojolicious> for documentation on web templating
and examples.

=head2 Command System

L<Mojo::Commands> is the interactive command line interface to the
L<Mojo> framework. It will automatically detect available commands in
the L<Mojo::Command> namespace (or others if so instructed).  Commands
are implemented by subclassing L<Mojo::Command>.

The command subsystem is normally started at the end of the
application startup script by calling (in C<Mojo> or C<Mojolicious>):

  Mojo::Commands->start;

In L<Mojolicious::Lite>-based applications, the command subsystem is
started with a call to the exported function C<< shagadelic(<args>)
>>, which calls C<< Mojolicious::Lite->start(@_) >>, setting up the
environment and starting up the command system (inherited from
L<Mojolicious>).

(If you are underage and have problems calling C<shagadelic()>, you
can call C<< app->start() >>, which is, in fact, the same.)

The command system provides on-line help (C<help>), application
framework generation services (C<generate>), information/utility
commands (C<version>, C<test>, C<generate makefile|psgi>, for
C<Mojolicious> applications also C<routes> and for
L<Mojolicious::Lite> C<inflate>) and start-up commands (C<daemon>,
C<daemon_prefork>, C<cgi>, C<fastcgi>, C<get>). See L</MOJOLICIOUS IN
PRODUCTION> for advice on choosing a suitable mode for running your
application in production environment.

Mojolicious command system is fully documented in L<Mojo::Commands>. Use the
help system to get full information on available options:

    mojo[licious]
    mojo[licious] help
    mojo[licious] help <command>
    mojo[licious] generate
    mojo[licious] generate help

To create a simple application and start it in auto reload mode (so
that it reloads itself if you edit the files), use:

    mojolicious generate app AppName
    cd AppName
    ./script/appname daemon --reload
    <load the page at the address provided>
    <edit application files>
    <reload page>

Since L<Mojolicious::Lite> applications are contained in a single
file, in the case of a "lite" application, this becomes simply:

    mojolicious generate lite_app appname
    ./appname daemon --reload
    <load the page at the address provided>
    <edit application script>
    <reload page>

=head2 HTTP server and client implementations

L<Mojo> implements a full HTTP 1.1 client and servers stack, with
support for IPv4 and WebSockets, abilities to listen on multiple
addresses and ports and optional support for IPv6, and SSL (if
suitable perl modules are installed).

The stack is implemented in several classes that act together and
interact with the application:

=over 4

=item L<Mojo::Server>

L<Mojo::Server> is an abstract HTTP server base class with different
implementations:

=over 8

=item L<Mojo::Server::Daemon>

L<Mojo::Server::Daemon> is an asynchronous IO HTTP 1.1 And WebSocket Server.

=item L<Mojo::Server::Daemon>

L<Mojo::Server::Daemon> is an asynchronous IO HTTP 1.1 And WebSocket Server.

=item L<Mojo::Server::Daemon::Prefork>

L<Mojo::Server::Daemon::Prefork> is a preforking version of the HTTP
1.1 And WebSocket Server.

=item L<Mojo::Server::Daemon::CGI>

L<Mojo::Server::Daemon::CGI> is a simple and portable CGI (common
gateway interface) implementation of the application server.

=item L<Mojo::Server::Daemon::FastCGI>

L<Mojo::Server::FastCGI> is a portable pure-Perl FastCGI implementation.

=back

=item L<Mojo::IOLoop>

L<Mojo::IOLoop> is a minimalistic event loop for TCP clients and
servers. It optionally supports alternative polling implementations
(L<IO::KQueue>, L<IO::Epoll> and connection types
(IPv6 with L<IO::Socket::INET6>, TSL with L<IO::Socket::SSL>). The support is
automatically activated if the support modules are installed on the
system.

=item L<Mojo::Transaction>

The server's application interface is centered around the concept of a
B<transaction> (usually represented as C<$tx> variable or C<< ->tx >>
attribute in C<Mojo> code and accessed through a controller C<$c> with
a C<< ->tx attribute >> in C<Mojolicious> code). L<Mojo::Transaction>
is an abstract base class with two implementations, the HTTP
transaction L<Mojo::Transaction:HTTP> and the WebSocket transaction
L<Mojo::Transaction::WebSocket>.

L<Mojo::Transaction> and most of the classes it uses are
implementations of L<Mojo::Stateful>, an abstract base class for state
keeping objects.

L<Mojo::Transaction> uses request and response message objects and
together with them encapsulates the state of the connection and
transaction in the server as it is driven by L<Mojo::IOLoop>.

=item L<Mojo::Message>

L<Mojo::Message> is an abstract base class for HTTP 1.1 messages with
two implementations for HTTP request (L<Mojo::Message::Request> and
response L<Mojo::Message::Response>).

Messages use a number of other classes:

=over 8

=item L<Mojo::Headers>

L<Mojo::Headers> is a container and parser for HTTP headers.

=item L<Mojo::Content>

L<Mojo::Content> is an abstract base class for HTTP 1.1 content with
implementations for multi-part and single content models
(L<Mojo::Content::MultiPart>, L<Mojo::Content::Single>).

=item L<Mojo::URL>

L<Mojo::URL> implements a subset of RFC 3986
(L<http://www.ietf.org/rfc/rfc3986>), for Uniform Resource Locators,
and is based on L<Mojo::Path>. It provides interfaces for processing,
accessing and constructing URLs. It represents URL in request.

It is also accessible at the application level, where the request and
response URLs are normally accessed indirectly through syntactic sugar
of C<< ->url_for() >> and C<< ->redirect_to() >> in default
controller.

See L<Mojo::URL>, also L<Mojolicious::Controller/url_for> and
L<Mojolicious::Controller/redirect_to> for reference documentation.

See description of C<< ->url_for() >> and C<< ->redirect_to() >> with
examples in L</CONTROLLERS AND ACTIONS>.

=item L<Mojo::Parameters>

L<Mojo::Parameters> is a container for form parameters and is used in
the request object of the transaction and for parameter parsing of URLs.

=item L<Mojo::Cookie>

L<Mojo::Cookie> is an abstract base class for HTTP 1.1 cookies with
implementations for request and response (L<Mojo::Cookie::Request>,
L<Mojo::Cookie::Response>).

=item L<Mojo::Upload>

L<Mojo::Upload> is a container for uploads.

=back

=item Support classes:

=over 8

=item L<Mojo::Filter::Chunked>

L<Mojo::Filter::Chunked> implements HTTP 1.1 chunked transfer encoding.

=item L<Mojo::Date>

L<Mojo::Date> implements HTTP 1.1 date and time functions according to RFC2616.

=item L<Mojo::Log>

L<Mojo::Log> is a simple logger for Mojo projects.

=item L<Mojo::Asset>

Mojo::Asset is an abstract base class for assets with implementations
for file and memory assets (L<Mojo::Asset::File> and
L<Mojo::Asset::Memory>).

=back

=back

=head3 HTTP Client

HTTP Client (ie., User Agent) is implemented using the same components
(and some others, such as L<Mojo::CookieJar>. It also supports full
featured asynchronious IO HTTP 1.1 and WebSocket connections with
optional IPv6, TLS, "epoll" and "kqueue" support. The client supports
C<get>, C<head>, C<put>, C<post> and C<delete> HTTP "verbs".

See L</USING MOJO HTTP CLIENT> for further information.

=head3 Using The Transaction Interface

The API (application interface) to the server stack in Mojo is
encapsulated in the transaction. The server is driven by IO loop using
call-backs set up by the server at its initialization, while the state
of the transaction is kept in the transaction object and its request
and response objects.

This is a low-level interface, to be used while extending the
framework or writing plugins. Applications should be using a
higher-level interface provided by L<Mojolicious> or a suitable
plugin. The interface is fully documented in L<Mojo::Transaction>.
To fully understand the interactions with C<Mojo::Transaction>, see
also L<Mojo::Stateful> and the implementation of its interface and state
machine in C<Mojo::Transaction>.

The transaction object provides access to the B<local connection>,
B<remote connection>, B<request> (with B<request type>, B<URL>,
B<parameters>, B<cookies>, B<content>, B<uploads> and direct access to
B<request environment>) and B<response> (with B<response code>,
B<message> and B<cookies>).

Some of the more important attributes of L<Mojo::Transaction>:

=over 4

=item C<connection>

    my $connection = $tx->connection;
    $tx            = $tx->connection($connection);

Connection identifier on socket. XXX add what this usually is.

=item C<local_address>, C<local_port>

    my $local_address = $tx->local_address;
    $tx               = $tx->local_address($address);
 
    my $local_port = $tx->local_port;
    $tx            = $tx->local_port($port);
 
    my $remote_address = $tx->remote_address;
    $tx                = $tx->remote_address($address);
 
    my $remote_port = $tx->remote_port;
    $tx             = $tx->remote_port($port);

=back

Some of the more important methods in L<Mojo::Transaction>:

=over 4

=item C<req>, C<res>

    my $req = $tx->req;
    my $res = $tx->res;

Transaction request and response.

=item C<is_websocket>

    my $is_websocket = $tx->is_websocket;

Check if the connection is a WebSocket.

=back

See L<Mojo::Transaction> for server/IOloop-interaction methods).

The request and response interfaces are usually accessed through the
transaction's C<< ->req >> and C<< ->res >> methods. Some of them are
available both on request and response, some of them are specific. To
mark the use, C<< ->{msg} >> (for message), C<< ->req >> and C<< ->res
>> will be used. I<Please note that> C<< ->{msg} >> I<is not actually
valid syntax>.

Request/response attributes:

=over 4

=item C<method>

    my $method = $tx->req->method;
    $req       = $tx->req->method('GET');

HTTP request method or "verb", XXX ie. one of "GET", "HEAD", "POST", "PUT", "DELETE".

=item C<url>

    my $url = $tx->req->url;
    $req    = $tx->req->url(Mojo::URL->new);

HTTP request URL, defaults to a L<Mojo::URL> object.

=item C<content>, C<headers>

    my $content = $tx->req->content;
    $req    = $tx->req->content(Mojo::Content::Single->new);
    my $headers = $tx->req->headers;
    $req    = $tx->req->header(Mojo::Headers->new);

Access to content and headers of a request.

=item C<params> and C<query_params>

    my $params = $tx->req->params;         # GET and POST
    my $params = $tx->req->query_params;   # GET only

All C<GET> (and for C<params> also C<POST>) parameters, defaulting to
a L<Mojo::Parameters> object.

=item C<env>

    my $env = $tx->req->env;
    $req    = $tx->req->env({});

Direct access to the environment hash if available.

=item C<default_charset>

    my $charset = $tx->req->default_charset;
    $req    = $tx->req->message->default_charset('UTF-8');

Default charset used for form data parsing.

=back

Request/response XXX methods:

=over 4

=item C<body>

    my $string = $tx->{msg}->body;
    $message   = $tx->{msg}->body('Hello!');
  
    $counter = 1;
    $message = $tx->{msg}->body(sub {
        my $self  = shift;
        my $chunk = '';
        $chunk    = "hello world!" if $counter == 1;
        $chunk    = "hello world2!\n\n" if $counter == 2;
        $counter++;
        return $chunk;
    });

Helper for simplified content access.

=item C<body_params>

    my $params = $tx->{msg}->body_params;

Access to C<POST> parameters. XXX difference with above attributes?

=item C<body_size>

    my $size = $tx->{msg}->body_size;

Size of the body.

=item C<to_string>

XXX

=item C<build>, C<build_headers>, C<build_body>

    my $string = $tx->{msg}->build;
    my $string = $tx->{msg}->build_headers;
    my $string = $tx->{msg}->build_body;

Render the whole message, headers or body.

=item C<cookie>

    my $cookie  = $tx->{msg}->cookie('foo');
    my @cookies = $tx->{msg}->cookie('foo');

Access a request/response cookie. XXX explain list context

=item C<cookies>

    my $cookies = $tx->{msg}->cookies;
    $req        = $tx->{msg}->cookies(Mojo::Cookie::Request->new);
    $req        = $tx->{msg}->cookies({name => 'foo', value => 'bar'});

Access request/response cookies. XXX expand, also on
Mojo::Cookie::Request, perhaps just in the cookie section.

=item C<param>

    my $param = $tx->req->param('foo');

Access C<GET> and C<POST> parameters, defaults to a L<Mojo::Parameters>
object. XXX expand

=item C<upload>, C<uploads>

    my $upload  = $tx->req->upload('foo');
    my @uploads = $tx->req->upload('foo');
    my $uploads = $tx->req->uploads;

Access specific or all file uploads. Actually implemented in
L<Mojo::Message>, so the methods are available also on response
object. XXX

=item C<proxy>

    my $proxy = $tx->req->proxy;
    $req      = $tx->req->proxy('http://foo:bar@127.0.0.1:3000');
    $req      = $tx->req->proxy(Mojo::URL->new('http://127.0.0.1:3000'));

Proxy URL for message.

=item C<is_secure>

    my $secure = $tx->req->is_secure;

Check if connection is secure.

=back

XXX Add some examples here ... And references to later sections.

See L<Mojo::Message>, L<Mojo::Message::Request> and L<Mojo::Message::Response> for full
reference documentation.

=head2 Mojo's Application Interface

L<Mojo> is a framework foundation (or I<meta-framework>, pick your
moniker), so it does not define a high-level interface to the
transaction. Instead, it provides an abstract method C<< ->handler >>
that your application can implement to handle the transaction.

    $tx = $mojo->handler($tx);

The handler is the main entry point to your application or framework
and will be called for each new transaction. An application or
framework built on C<Mojo> should implement its transaction handling
interface by implementing a C<< ->handler >> method.

L<Mojo> also implements the C<< ->start >> method for application
start. It sets up C<$ENV{MOJO_APP}> environment variable and starts
the application command system (see L</Command System>) which performs
the actual application start and handover to an implementation of L<Mojo::Server>:

    Mojo->start;
    Mojo->start('daemon');  # start in daemon mode: Mojo::Server::Daemon

L<Mojo> also implements a number of attributes, such as C<< ->client
>> to access a full featured HTTP 1.1 client for use in your
applications, C<< ->home >> that stringifies to the path of the home
directory of your application and C<< ->log >> to access the logging
layer of your application.

See L<Mojo> for reference documentation.

=head2 MojoX: Dispatchers, Controllers, Renderer

C<MojoX> introduces a number of new concepts:

=over 4

=item dispatcher

B<Dispatcher> finds the correct action for the given request. C<MojoX>
implements two dispatchers, L<MojoX::Dispatcher::Static> for serving
static types, and L<MojoX::Dispatcher::Routes> for dynamic dispatching
based on the routes concept (see L<Dispatching with Routes> for
explanation).

The static dispatcher is simple: it has three attributes: C<type>, a
MIME-type database (L<MojoX::Types>) to map files to proper MIME
types, C<prefix> to remove from the requested URL and C<root> to add
to the request path to generate the correct file system path. It is
accessed by two general methods, C<dispatch($c)> is called with a
controller object and is the normal way to call the dispatcher, while
C<serve($c, '/path/to/file')> can be used to serve a specific file for
a request.

The routes dispatcher merits its own section: L<Routes Dispatcher>

=item controller

B<Controller> is the web application developer side of the
"controller" from the Model-View-Controller paradigm: it defines
interfaces to access the transaction and support systems to connect to
the view (rendering, in L<Mojolicious>). L<MojoX::Controller> is
actually an abstract base class for
L<MojoX::Session::Cookie::Controller> (with cookie and session
support) and L<MojoX::Dispatcher::Routes::Controller> to integrate
with routes.

The routes controller merits its own section: L<Routes Controller>

=item stash

The B<stash> is a request-scoped hash for data used by controller,
renderer and their components to produce content. It is used as a
general data-passing mechanism between these elements and is
automatically populated by parameters, route named parameters etc. It
is a non-blessed hash reference shared between controller, renderer
and its handlers/helpers.

=item renderer

The B<renderer> is implemented in L<MojoX::Renderer>. It turns the
data in the stash into content suitable for serving to the client.  It
has a flexible architecture, supporting multiple handlers
(template/file format engines) and helpers (sub-engines).

The renderer also merits its own section: Routes Dispatcher and Controller
L<Renderer, Handlers, Helpers, Templating engines>

=back

=head3 Routes Dispatcher

The routes dispatcher is usually instantiated and set up in the
application start up code (see L<Mojolicious Application Interface>
for examples in the context of a Mojolicious application):

     my $r = MojoX::Dispatcher::Routes->new;
     $r->route('/:controller/:action/:id')->to('example#welcome', id => 1);

The task of the dispatcher itself is simply to find a combination of
class and method in the application namespace to fulfill the
requirements of the controller/action specification in the routes
request. The route matching itself is peformed by its base class,
L<MojoX::Routes>. The dispatcher has a simple interface. It defines
three attributes:

=over 4

=item C<namespace>

C<namespace> is the namespace to search for controllers

=item C<controller_base_class>

C<controller_base_class> is the base class used to identify
controllers: objects without this class in their inheritance trees
will not be accepted as valid controllers.

=item C<hidden>

C<hidden> is an array of methods and attributes that are hidden from
the dispatcher and are not considered as valid candidates for actions.

=back

It has only two public methods, C<hide> as a helper to add to the
C<hidden> attribute and C<dispatch>, the entry point to the
dispatching process:

    $dispatcher->dispatch($c);

It has a number of internal methods implementing class and method
generation and walking of the stack of routes as represented by
L<MojoX::Routes::Match>, a Routes visitor class.

It also implements embedded application detection and dispatching
to/from embedded applications. See L<Embedding Applications> for more
information.

The actual routes semantic is defined in L<MojoX::Routes>, the base
class of the routes dispatcher.

XXX interface with explanations, and very interesting explanations these will be


=head3 Routes Controller

The controller, usually written as C<$c> in the examples, is the base
class for most of the application code, since routes dispatcher
dispatches requests to controller (an application class) and action
(its method). So you should think of the controller more in the terms
of the C<$self> object in your application's actions:

    warn "The argument for 'month' was " . $self->param('month');
    my $month  = $self->param('month');
    $self->render_text("The month param was $month.");

=for consideration
XXX explore this whole placeholder/params over
param/stash/template_namespace thing more

XXX controller interface here

Controller and Action

=head3 Renderer, Handlers, Helpers, Templating engines

=begin consideration

<ask_> <%= $self->render_partial('_common/code'); %> -- shouldn't the result of the _common/code template be html escaped?
<sri> ask_: nope, render results are a special case like in rails and django
<sri> same for some .ep helpers
<ask_> what's rails or django?  :-)  (just kidding).
<ask_> ok -- what's the mojo way to escape the render result then?
<sri> the result is wrapped in a Mojo::ByteStream object, so you should be able to just append ->to_string and force escaping
<sri> ->render_partial(...)->to_string
<sri> the Mojo::ByteStream object is what prevents escaping
<ask_> cool, thanks.
* sri makes a note to mention it in a guide

=end consideration

=head2 Mojolicious Application Interface

L<Mojolicious> is based on the L<Mojo> framework foundation /
meta-framework and extends its interface.

XXX this is not clear and needs cleanup:

The core of the transaction interface is its implementation of the C<<
->handler >> method, which sets up the environment for Mojolicious
applications.

XXX full Mojolicious interface here:


=begin note

"process":  $mojo->process($c);

This method can be overloaded to do logic on a per request basis, by
default just calls dispatch.  Generally you will use a plugin
or controller instead of this, consider it the sledgehammer in
your toolbox.

=end note


A Mojolicious application is initialized by a call to the main
application package method C<startup> at server start, usually used to
set-up routes and perhaps initialize the model:

  package Test;

  use strict;
  use warnings;

  use base 'Mojolicious';

  # This method will run once at server start
  sub startup {
      my $self = shift;
 
      # Routes
      my $r = $self->routes;
 
      # Default route
      $r->route('/:controller/:action/:id')
        ->to(controller => 'example', action => 'welcome', id => 1);
  }
 
  1;

(This is where the C<$ENV{MOJO_APP}> environment variable, set up by
the application script is used by the command system to locate the
right package.)

When Mojolicios application is called with a transaction, the
Mojolicious C<handler> instantiates the default controller class
(usually L<Mojolicious::Controller>, with a rather contorted
inheritance tree of C<isa> L<MojoX::Dispatcher::Routes::Controller>
C<isa> L<MojoX::Session::Cookie::Controller> isa
L<MojoX::Controller>), set with the C<controller_class> attribute)
with attributes for the application (C<app>), stash (C<stash>) and the
transaction C<tx>) and call C<< ->process >> on the class.

Then the default controller and its dispatcher know how to find the right
application controller and action for each request and maps them to the
application's package and its method:

   ->to(controller => 'example', action => 'welcome')  # Test::Example->welcome

Usually, the controller is a subclass of the default controller with
all its functionality (renderers, handlers, templating engines,
helpers etc.:

    package Test::Example;
    ...
    use base 'Mojolicious::Controller';

XXXX

by calling C<process()>, an ideal entry point for subclassing:

    sub process { shift->dispatch(@_) }

XXXX

, a request is first subject to B<dispatching>, where
the proper action is found based on the URL path of the request. There
are two dispatchers: first L<MojoX::Dispatcher::Static> is called, a
simple dispatcher for static files, by default serving up files found
under C<public/>. If the static dispatcher fails,
L<MojoX::Dispatcher::Routes> is tried.

XXXX

=head2 L<Mojolicious::Lite> Application Interface

XXX Explain how it is implemented;
How we have only one controller;
How exactly we parse for templates;
How bridges come to be ...


=head1 CONTRIBUTING TO L<Mojolicious>

Mojolicious is developed using a GitHub repository
(L<http://github.com/kraih/mojo>). Developer communicate primarily on
IRC (C<#mojo@irc.perl.org>) and using a Google groups mailing list
(L<http://groups.google.com/group/mojolicious>).

If you want to submit a patch, the best way to do it is to set up a
repository on GitHub (forking is offered at the repository-to-be-forked
after you have logged in, more info at
L<http://help.github.com/forking/>) and set it up to track the
upstream. The set-up is different from what you would do if it was
your project, since you pull from upstream and push to your own
repository. This is how you can do that:

  $ git clone git@github.com:<your-name-here>/mojo.git #private URL!
  $ cd mojo
  $ git remote add upstream git://github.com/kraih/mojo.git

Then you should clone the repository locally using C<git>, branch it and
make your changes in a new branch:

  $ git branch <meaningful-feature-or-bug-name>
  $ git checkout <meaningful-feature-or-bug-name>

This is the time to do your work. Do not forget to prepare suitable
tests (see bellow) and update/create reference documentation.  When
finished, this is how you publish your changes:

  $ git add <your-files>
  $ git commit -m <meaningful-name>
  $ git push

Now you should use the B<Pull Request> facility at GitHub to notify
the developers, and probably say so on IRC or the mailing list. This
approach will permit the core developers to merge in your changes.

At the same time, you will be able o track the upstream in your
master branch:

  $ git checkout master           # back to the master branch
  $ git fetch upstream master
  $ git merge upstream/master

The fetch/merge combo can be expressed also as:

  $ git pull upstream master

You can optimize this by changing the default set-up and add this to
the C<.git/config> file in your repository:

  [branch "master"]
          remote = upstream
          merge = master

No you can fetch and merge upstream into your master simply by saying:

  $ git pull upstream

To start a new patch, repeat the branching and check-out process above.

Note: Needing to use a new branch for every commit-set is admittedly
unusual, but upstream will likely squash and modify your commits before
applying, so merging them back will be an non-trivial process, and
your history will become unnecessarily complicated.

C<git> will take care of efficiency and facilitate the process for
you. There is plenty of documentation for new C<git> users with the
package, on C<git> site at L<http://git-scm.com/> and at GitHub:
L<http://help.github.com/>.

=head2 Working With Parallel Versions

When contributing to the framework, you will need to have different
versions of the distribution accessible, either to compare or
benchmark or to use a stable release for your own projects and
applications while working on a new feature.

You should be familiar with the possibilities, but to make things
simple, let us review the options:

You can run L<directly from the source tree> (assuming bash):

   $ PERL5LIB=./lib:$PERL5LIB script/mojolicious <command>

To make this permanent:

   $ export PERL5LIB=`pwd`/lib:$PERL5LIB
   $ export PATH=`pwd`/script:$PATH

To make this sensible, you should use make to create C<blib> and then
do:

   $ WORKDIR=/path/to/repository/blib
   $ export PERL5LIB=$WORKDIR/lib:$PERL5LIB
   $ export PATH=$WORKDIR/script:$PATH

You might still get issues due to the fact that both your development
and the released versions are available in the search path. The only
way to solve this problem is to have both installed in non-standard
locations.

A refresher:

  $ mkdir ~/usr ~/devel
  $ cd <distro_workdir>
  $ perl Makefile.PL PREFIX=$HOME/usr
  $ make test && make install
  $ cd ../<devel_workdir>
  $ perl Makefile.PL PREFIX=$HOME/devel
  $ make test && make install
  $ # writing interesting scripts to set up environment
  $ # left as an exercice for the reader

=head2 Requirements for code submission

Please do not forget that Mojolicious is developed with an agile
development model and much effort is invested into having as complete
testing coverage as possible. For that reason, bug reports and feature
patches generally B<require suitable tests>. If you can produce a test
for a bug you have found, the chances of getting a quick fix are much
better.

Submitting a test is best done with the same method or, alternatively,
you can send the file to the mailing list or use C<nopaste> (perhaps
L<http://mojopaste.com/> or L<http://showmetheco.de/>) on the C<#mojo>
IRC channel.

In addition, you should follow the Mojo coding guidelines, as
described in L<Mojolicious::Guides::CodingGuidelines>.

(If you are hopeless when you realize that a Futurama (or The
Simpsons) quote is needed for each file, do not despair:
L<http://www.google.si/search?q=futurama+quotes>, for example
L<http://www.thatwasfunny.com/category/cartoons/futurama>. Try not to
repeat existing quotes in the code.)

=head2 Extending Mojo and Mojolicious: L<MojoX> and Mojolicious Plugins

The proper way to extend the framework depends on the kind of
extension in question. The developer needs to remember that L<Mojo> is
the framework for framework development, to be extended in the
L<MojoX> namespace, while L<Mojolicious> is an implementation of a web
framework on top of L<Mojo> with some L<MojoX> extensions.

Therefore, if the extensions bring in functionality that is not
strictly specific to L<Mojolicious>, it should be implemented as a
L<Mojo> extension in L<MojoX> namespace. If it can be used under
L<Mojolicious>, a plugin wrapper based on L<Mojolicious::Plugin>
should be added to facilitate the integration in L<Mojolicious> and
L<Mojolicious::Lite> applications.

If the extension functions strictly in the context of L<Mojolicious>,
it should be implemented as a Mojolicious Plugin.

=head3 Extending Mojolicious with Plugins

Please note that besides plugin hooks, plugins can integrate with
renderers by adding B<handlers> and B<helpers> and with routes by adding
B<conditions>:

  # Mojolicious/Plugin/I18n.pm:
  $app->renderer->add_helper(l => sub { shift->stash->{i18n}->localize(@_) });
  
  #Mojolicious/Plugin/PodRenderer.pm
  $app->renderer->add_handler( pod => sub { ... } );
  
  #Mojolicious/Plugin/AgentCondition.pm
  $app->routes->add_condition( agent => sub { ... } );

See L<Mojolicious::Plugin> for reference. Plugins shipped with
Mojolicious have a number of advanced examples.


=begin considering

<marcus> hrm, might be a problem with the template options
<marcus> sri: plugins can't take options right?
<marcus> I guess they can

=end considering

=head1 COOKBOOK

Most of the following subsections should eventually find their proper
home in the proper section of the handbook. They are here as a work in
progress, and some will remain as useful tips.

See L<Mojolicious::Guides::FAQ> and L<Mojolicious::Guides::Cookbook> for
more info.

=head2 Log Files and Debugging

=begin consideration

(06:11:42 AM) sri: development mode with debug log level is the default
(06:12:00 AM) tempire: Yeah, I see that now.  I was just mixed up since this is the first time I've used app instead of lite_app
(06:12:18 AM) sri: :)
(06:12:47 AM) sri: ah, didn't read backlog that far
(06:13:01 AM) su-bzero [~komslavik@mcc-dyn-241-148.kosnet.ru] entered the room.
(06:15:10 AM) sri: tempire: you can delete the log directory to make it log to stderr btw
(06:15:19 AM) tempire: excellent
(06:15:25 AM) tempire: thanks
(06:41:50 AM) marcus: that's a handy piece of advice
(06:41:55 AM) marcus: is it in docs anywhere? :)

=end consideration

=head2 Content-type and C<MIME>

=begin consideration

13:32	maettu	how can I manually set Content-Type to "application/javascript"?
13:51	sri	maettu: $self->res->headers->content_type(...) or $self->render(..., format => 'js')

=end consideration

=head2 Language support

=head2 Encodings

=head2 Content types

=begin consideration

static:  vti: you can always set content_type header by yourself

(11:43:21 PM) vti: look at how i server static files in pastelicious
(11:43:26 PM) vti: and do different outputs
(11:43:32 PM) vti: html text json
...
(11:45:05 PM) vti: hm, i use there types app->renderer->types->type(html => 'text/html; charset=utf-8');

$res->headers->content_type('image/jpg');
$self->render_text($binary_data);
 => now actually render_data!!

=end consideration

=head2 Source file and template encoding

Templates have an C<encoding> attribute, which, luckily, is set to
C<UTF-8> by default.

XXX No idea how to use it. A helper would be nice.

=for consideration
vti: renderer has ->encoding option

For XXX templates in __DATA__ sections, the file encoding is in effect, so
do not forget to use C<use utf8;> if you plan to use Unicode in your templates.

=head2 Embedding Applications

=head3 Embedding Mojolicious apps

=head3 Embedding Mojolicious::Lite apps

=head2 C<JSON>, C<RSS> and Atom

=head2 Ajax

=head2 WebSockets

=for consideration
Ie. rendering C<JSON> directly to a WebSocket:
sri: well, you can already do $self->send_message($self->render_partial(...));


=head1 ACKNOWLEDGEMENTS

=over 4

=item Sebastiean Riedel

For achieving it all

=item Jan Jona Javoršek

For noncomprehending comprehensively

=item Anatoly Sharifulin

For understanding, both meanings

=item Вячеслав Тихановский [Viacheslav Tykhanovskyi]

For being patently patient

=item Mirko Westermeier

For trying and telling

=item Everyone at C<#mojo@irc.perl.org>

For clues and contributions

=back

=begin consideration

IOLoop:
Optional modules L<IO::KQueue>, L<IO::Epoll>, L<IO::Socket::INET6> and
L<IO::Socket::SSL> are supported transparently and used if installed.

How to set the CA file? What is the default?
--listen https://*:port:tls_cert:tls_key
Cert auth ideas?

Daemon:
$c = connection?

MojoX/Dispatcher/Static.pm:
looks up type via extension, defaults to text/plain
how to extend types?

MojoX/Dispatcher/Routes.pm:
capures go to stash
then params get captures mixed in hmm


Old typo!
Typo: MojoX/Dispatcher/Routes/Controller.pm
L<MojoX::Dispatcher::Routes::Controller> inherits all attributes from
L<MojoX::Session::Simple::Controller> AND implements the following 
attributes.


Tests:
<sri> vti: i always load Test::Mojo after Test::More
<vti> good to know :)
...
* sri sets vti on fire
<vti> maybe that should go into Test::Mojo docs? so noone else will get into this trouble
<sri> i did not expect anyone trying to use Test::Mojo without a plan
...
<vti> sri: doesn't work
<sri> Oo
<sri> vti: then your app might be screwed up
<sri> you need to pause before it leaves the routes dispatcher or plugin hooks run
<sri> if you pause after that they run twice
<sri> and there is nothing that could be done


10:52:35 PM) sri: you should get an error about the pid file
(10:53:20 PM) vti: sri: at least named after my app ;p
(10:53:29 PM) vti: and no errors reported
(10:53:35 PM) xantus: you can pass --lock= and --pid


(05:54:50 AM) stephen: Any clever way to have Mojo download a file as an attachment?
(06:29:09 AM) stephen: Can I subclass MojoX::Dispatcher::Static?
(07:40:44 AM) janus: can't you just set a content-disposition header
first and refactor the code later?
(07:43:15 AM) janus: still i assume that's a question that might
better be placed in the faq or something


http://www.slideshare.net/sharifulin/mojo-en
http://sharifulin.livejournal.com/tag/mojo

Twitter: @kraih @vtivti @sharifulin
Juick:   @vti @sharifulin

<marcus> you should see kane's black perl talks.
http://oslopm.blip.tv/file/1903160/

(04:51:23 AM) sri: MOJO_RELOAD can't handle everything
(04:51:45 AM) sri: if your screw up is big enough it won't recover

(09:19:00 AM) sri: "PATH_INFO=/foo ./myapp.pl" will just work :)
(09:20:01 AM) sri: simplicity++
(09:20:29 AM) sri: "./myapp.pl get /" is still easier though for testing

=end consideration

=begin comments

<ask_> KiokuDB is very nice, FWIW.  :-)
<sri> i'm a huge fan of couchdb
<sri> random secret with persistence is an interesting idea
<ask_> There's a CouchDB backend for Kioku.   In my current toy-mojo-project I use MongoDB as the backend.
<ask_> http://www.iinteractive.com/kiokudb/arch.html
<garfield> [ KiokuDB Architecture ]
<sri> don't really like mongodb, bson is a deal breaker for me
<sri> prefer memcached or rest api
<sri> with json
* sri expects cool websocket based json protocols in the future
<ask_> sri: the MongoDB.pm module is easy enough to work with (and very fast).
<ask_> (not that I disagree that JSON is nice)

<GitHub86> mojo: master Sebastian Riedel * a911b4d (5 files in 4 dirs): improved PSGI support and added "psgi" command - http://bit.ly/dwRY6k
* GitHub86 (~GitHub86@sh1-ext.rs.github.com) has left #mojo
<sri> this turns Mojolicious::Lite apps into valid .psgi files :)

<Su-Shee> I can use lighthttpd with mojo, right?
<sri> sure
<Su-Shee> *sigh* I have to prepare a mojo, a ruby & ror, a comparison perl web frameworks and a moose developer lesson. 
<Su-Shee> this is going to be an interesting setup ;)
<sri> lighttpd got quite unpoluar recently
<Su-Shee> why's that?
<Su-Shee> hm. which reminds me.. do I even need a web server on its own... 
<sri> because of nginx i guess, which is much better
<sri> you could just use the buit in server
* su-bzero has quit (Quit: .))
<sri> it's quite good
<sri> and more than enough for demonstrations
<Su-Shee> hm, I could do a performance/load test with it anyway because I have to write a couple of test clients.
<Su-Shee> and our load is on the db anyway; it's really not heavy httpd requests...
<sri> prefork daemon should be fine then
<sri> on my macbook i can tune it up to about 2k req/s
<sri> which is much more than any framework can deliver anyway
<Su-Shee> 2k/s?! the little perl module or nginx?
<sri> little perl module
<sri> nginx scales way further
<sri> which doesn't matter much for frameworks, since they can't deliver that fast anyway :)
* alex has quit (Read error: Connection reset by peer)
<Su-Shee> little fluffy perl module it is. nice test. let's see how much "real web server" we really need. 
<Su-Shee> I'm pretty sure it's more than enough for our stuff.
<sri> for a small scale benchmark you can try "mojo daemon_prefork" and run "ab -c 30 -n 10000 -k http://127.0.0.1:3000/" against it
<sri> or "mojo daemon_prefork --clients 10" for async io
<sri> async scales much better but doesn't work very well with blocking dbi calls
<Su-Shee> what we have is a couple of thousand users per installation and mostly a usally large db because the stuff large files into it. and if session stuff actually is done in dom storage, the db isn't under that much load anymore. 


10:03:49 PM) rindolf: sri: how should I pass the POST parameters on a post query?
(10:03:53 PM) sri: and write docs in between ;p
(10:04:31 PM) sri: rindolf: the mojo client has a post_form method that does most of the work
(10:05:09 PM) sri: there are many many tests using it, espcially for newer encoding checks

CouchDB link and syn/async info:
<esskar> vti, sri http://showmetheco.de/5e02cf4d8d52f4086e400106808b94beb4a87158 check the example (and sub revisions in MojoX::CouchDB::Doc) at the end; this is what i meant about the async behaviour
* garfield has quit (Ping timeout: 360 seconds)
* garfield (~garfield@84-74-63-71.dclient.hispeed.ch) has joined #mojo
<sri> esskar: you need a second callback to make it async
<esskar> where?
<sri> ->revisions(sub {...});
<sri> otherwise it only works blocking
<esskar> how do i siwtch to blocking?
<esskar> i do not want async :)
<sri> you use your own ioloop instance
<sri> and not the singleton
<sri> Mojo::Client->new(ioloop => Mojo::IOLoop->new)
<sri> that should make it blocking to the outside
<sri> for your client attribute
<sri> you can't be half async though
<sri> all or nothing :)
<sri> alternatively you could use two client instances
<sri> one for async and one for sync ;p
<esskar> is set __PACKAGE__->attr(is_async => 0); now
<esskar> used the new client code above
<esskar> but it sub revisions returns before the inner callback has finished
<sri> but is_async does nothing
<esskar> anyways :)
<esskar> and i do not see how i change that behavior
<sri> esskar: you should just add a second callback and be done with sync and async
<esskar> as much as i am a fun of asynchronous calls it is not the behaviour that i want here ...
* esskar falls back to LWP::Request
<sri> esskar: Oo
<sri> just make your client instance sync
<sri> esskar: __PACKAGE__->attr(client => sub {Mojo::Client->new(ioloop => Mojo::IOLoop->new)});
<sri> that client will block whenever you call process
<esskar> sri: nope
<sri> then you are registering new requests inside a callback on the same client instance
<sri> just use a new client instance
<esskar> let me see
<sri> my $client = Mojo::Client->new(ioloop => Mojo::IOLoop->new;
<sri> );
<sri> if you want to block inside a blocking request you of course need a new blocking client ;p
<sri> thats what i meant when i said using two clients before
<esskar> sri++
<esskar> thanks
<sri> one could be async and one sync... possibilities are infinite :)
* esskar raises up to Mojo::Client
<sri> i've been thinking about just adding a ->blocking method to Mojo::Client
<sri> but i'm afraid it will encourage people to mix sync and async without understanding the basics
<sri> you can only turn the whole client instance into sync mode
<sri> not individual requests
<esskar> i see
<sri> multiple requests will run parallel even in a blocking client
<sri> thats why you just had a problem
<sri> oh, i think i could implement ->blocking in a sane way by checking if we already have running requests in queue
<esskar> sri: http://showmetheco.de/50cffb9a5804bd407f894ce13806e194d19c816b much better now, thanks
<sri> oooh, we could do $client->new_blocking
<sri> they could share cookiejar and stuff
<esskar> sounds nice
<sri> my $c2 = $c1->new_blocking
* sri nods
<sri> thats good
<sri> that leaves all instance specific data untouched
<sri> maybe $client->clone_blocking would be more appropriate
<esskar> $client->clone(blocking => 1)
<vti> esskar: you read my mind?!
<sri> $client->blocking_client;
<sri> clone has generally a special meaning
<esskar> adding words behind keywords doesn't look good
<sri> $client->sync_client;
<esskar> yes, but then you could have $blockingclient->clone(blocking => 0)
<sri> esskar: that would do nothing
<esskar> why not?
<sri> what would it do?
<sri> and why? :)
<esskar> returns a new async client
<esskar> why? because!
<sri> i never add features just because i can ;p
<esskar> you should :)
<esskar> maybe you do not see it now, but you may in the future
<sri> do one thing and do it well
<sri> my $c2 = $c1->blocking;
<sri> that looks good in code
<sri> $c1->blocking->get(...)->process;
<sri> no negative side effects
<sri> and you don't really have to think about using a second client instance
<sri> the second instance will just vanish when it's done
* sri likes
<sri> thats actually really nice
* sri wonders if it would be a better idea to make Mojo::Client blocking by default and add $client->async->get(...)->process
<sri> it shouldn't break anything
<vti> yes, blocking by default is a good idea
<sri> that removes the default need for pause/resume in mojolicious
* sri nods
<sri> people shouldn't have to care about it by default
<sri> it's advanced
<sri> the mojolicious client would become dead simple to use
<sri> ohoh one problem though
<sri> requests registered inside a callback
<sri> process would have to become a little bit smarter i guess
<sri> think i can make nested ->request calls blocking too :)
<sri> umm... nested ->process
<sri> async in the future will look something like $self->pause; $self->client->async->get('http://mojolicious.org' => sub { $self->finish });
<sri> and sync just $self->client->get('http://mojolicious.org' => sub {...});
<sri> the current hybrid thingy will result in sync
<sri> very userfriendly
<vti> why not just return $tx in sync mode without a callback?
<sri> ?
<sri> you can still make multiple parallel requests
<vti> ah
<sri> it will just block until all are done
<sri> ops
<sri> forgot ->process
<sri> in my examples
<sri> it's still there
<sri> i wonder how my $tx = $self->client->get('http://mojolicious.org'); could be realized
<sri> i might be able to do it
<sri> lets see
<sri> yay, sync/async client working :)
<sri> even have a double proxy example working to compare performance
<sri> wow
<sri> async proxy is exactly 6.5 times faster :)
<sri> lets see if we can get "my $tx = $client->get('http://mojolicious.org');" to work now

AND sync/async explained
<sri> you need to call ->pause before calling client then later call ->finish in the callback, and render explicitly inside the callback
<sri> basically...do everything inside the callback
<marcus> so finish does not continue where you've paused?
<sri> doesn't work that way
<sri> you can't pause in place
<sri> if you were passing control back to the event loop from inside your action it would end up in a deep recursion
<sri> sadly
<marcus> yeah, that is sad
<sri> there is no easier way afaik :/
<sri> welcome to the wonderful world of event loops!
<marcus> when using other parallel clients you usually block in the process call
<marcus> guess I can do that by using a diff. ioloop
<sri> yes, it blocks the server though
<sri> unless you do prefork with one process per client connection
<marcus> sure
<marcus> well, waiting for dbi data blocks the server too
<sri> ye
<vti> anyevent adapter for mojo would be nice... you get all good stuff like async dbi, dns etc ;)
<sri> well, gimme an hour and you can block your server with parallel requests out of the box ;p
<sri> vti: feel free
<marcus>     $self->client->ioloop(Mojo::IOLoop->new);
<sri> ye
<marcus> in startup made stuff work the way I wanted
<marcus> I can still do multiple process calls?
<sri> you can
<marcus> good enough for now then
<sri> vti: async dbi would still suck though ;p
<vti> sri: ye, dbi sucks anyway! long live nosql!
<marcus> freebeer
<marcus> I quite like couchdb

<esskar> are you planning MojoX::CouchDB yourself?
<esskar> sri, if not (and if vti agrees), i may release it later on
<esskar> are what namespace should be used for Mojo stuff that is not diretly part of Mojo?
<sri> actually i did plan a MojoX::CouchDB
<sri> but there is a lot of stuff higher on my todo list
<sri> so just go ahead and release
<marcus> vti: did you say you have a nice couchdb model?
<vti> marcus: esskar is implementing one
<marcus> k
<marcus> Guess I'll be needing a lot of parallel requests for this project :)
* ferreira is now known as ferreira|away
<marcus> esskar: how far have you gotten with that?

<sri> since version 14 it just add new cookies
<sri> *adds
<vti> ye, that's it
<vti> i haven't checked mojox-session since then oO
<sri> Oo
<vti> and i see that there is way to delete a cookie
<vti> *no way
<sri> they get directly turned into headers ye
<sri> i guess cookie header creation could be delayed until fix_headers... but that would require many many new tests :)
<vti> no, no
<vti> that's ok
<sri> then again, deleting headers is of very limited use

<vti> any suggestions how i can write an app that has a main server and many workers and server passes some info to idle workers, and then workers tell server when they are ready for more info?
<vti> that's just a general perl question... but you are smart :)
<sri> thats basic prefork stuff, just multiplex pipes in the parent process
<vti> ye, but should i open a pipe for every worker?
<sri> ye
<sri> good thing about pipes is that the first 512 bytes written are atomic
<vti> oh, good to know
<sri> makes packet handling easy
<vti> thanks

(10:43:27 PM) mvuets: I like trailing slash, like site.com/stuff/ Is it hard to ask Mojolicious to use them?
(10:44:22 PM) sri: mvuets: routes don't use them, but we try to preserve the information in the url object
(10:44:44 PM) sri: you could build a condition checking it i guess
(10:45:08 PM) sri: ->req->url->path->trailing_slash
(10:45:55 PM) sri: i've thought about adding slash support to the routes implementation, but so far i've not found a good syntax
(10:47:37 PM) mvuets: Nice. Thanks

(12:25:12 AM) mvuets: Why <%= things %> are evaluated in a list context?
(12:25:55 AM) sri: possibly the way it's compiled
(12:26:06 AM) sri: $_M .= things;
(12:26:55 AM) mvuets: Concatination is scalar.
(12:27:17 AM) sri: just telling you what it gets compiled to, no idea what things is

<tempire> Does mojo have a built-in way to access the #hash at the end of a url?
<sri> thats client side
<sri> it doesn't get sent to the server
<sri> it's called the fragment

<tempire> I presume the best way to handle initial processing for all requests would be a bridge, say to a sub in Root.pm
* sri nods

<tempire> I presume the charset plugin is for putting charsets in the content-type header of each response
<tempire> Of which the correct usage would be: __PACKAGE__->plugin( charset => { charset => "utf-8" } ); in MyApp.pm
<sri> tempire: the plugin does more than that
<sri> charset handling is very complicated
<sri> for example browsers won't set a charset when submitting forms and just use the charset the form page was sent in, so it is impossible to detect on the server side and the plugin sets a default
* arthas has quit (Quit: Lost terminal)
<sri> so just pick a charset, use the plugin to set everything up, enjoy everything just working

<thenduks> hello groovy people, loving mojo, need to ask though since I can't find it in the docs (some broken links around?) - how/where do I setup some constants I need throughout my app (say, $IMAGE_DIR) so they can be accessed in controllers/etc?
<sri> you could use the json config plugin
<sri> it will read a json config file on startup and put the contents into the stash as "config" for every request
<sri> quite convenient
<thenduks> ah ha I saw something about 'stash'
<thenduks> but can't find the actual docs for it
<sri> Mojolicious::Lite contains a good tutorial
<thenduks> Yea that's actually my general problem, I started with a Lite app, but now I'm moving to a regular one and basically all the stuff at the top I have no idea where to put
<sri> i see
<thenduks> so I have code to make sure $IMAGE_DIR exists and so on
<thenduks> i also have code like app->secret('...')
<sri> that would all go to the startup method in MyApp
<thenduks> but 'app' doesn't seem to mean anything in my main app module
<thenduks> right that's where I'm trying to put it
<sri> sub startup { my $self = shift; $self->secret(...) }
<thenduks> so I figure shift->secret('...') and so on
<thenduks> i got that part
<thenduks> yea :)
* sri nods
<thenduks> so if I do $self->stash that should get me int he direction i need for 'global' stuff
<sri> nope
<sri> stash is request scope only
<sri> what you want is to add attributes to MyApp
<sri> the app instance can be accessed from controllers via $self->app
<sri> the json config plugin uses special plugin hooks to initialize the stash
<thenduks> ah i see
<sri> you could overload "process" in myapp to do it yourself, but it's unneccessary
<thenduks> where do I find this plugin?
<sri> Mojolicious::Plugin::JsonConfig
<sri> $self->plugin('json_config')
<sri> t/mojolicious/ contains multiple test apps using it
<thenduks> ok
<thenduks> well, in my lite app I had: my $IMAGE_DIR = app->static->root . '/images';
<thenduks> clearly I can't put that in myapp.json
<thenduks> the app->static->root part i mean
<sri> actually you can :)
<sri> <%= app->static->root %>
<thenduks> ah excellent
<sri> it's epl preprocessed
<sri> with a helper named app
<thenduks> i'm sure i will see that is the case when I read the JsonConfig docs :)
<thenduks> ok well I think I've got enough to keep going now
<thenduks> thanks a lot
<thenduks> hey sri: one last question if you're still around
<thenduks> if stash is only available during a request then how would I use what I put in my json configuration and do some initialization based on it (say, making sure the directory exists, etc)?
<sri> $config = $self->plugin('json_config');
<sri> ;)
<sri> check it on startup
<thenduks> ohh i thought it was saying it populates stash ('period')
<thenduks> as in, it's always in stash after you load it
<thenduks> but yea, i get it
<thenduks> thanks
<thenduks> :)
<sri> it will be in the stash, but it does more than that :)
<sri> like i said, it's very convenient
<thenduks> very convenient indeed
<sri> the returned hash is a reference to the actual hash that goes into the stash btw. so you can even change values
<sri> theoretically you could also run your checks inside the json config file since it's a epl template ;p
<sri> but that wouldn't be as clean
<thenduks> yea i'd rather not do that
<thenduks> but your other point is interesting, that means you can put stuff that isn't json at all in there
<thenduks> in the initialization of the app
<thenduks> right?
<sri> right
<thenduks> i mean, the json is only for the initial load
<sri> actually you could entirely skip the json file if you set defaults when loading the plugin
<sri> plugin json_config => {default => {foo => 'bar'}};
<sri> you'll only get a debug log message, and thats it
<thenduks> right, i could populate it all in startup
<sri> and you would still have the option to just add a json config file later on without any additional work
<thenduks> so would it be a bad idea to put a logger in there?
<thenduks> $config->{'logger'} = Mojo::Log->new;
<thenduks> i suppose there's an easier way to handle logging, but i mean, as an example
<sri> thenduks: you could even build a configurable plugin loader, it's all up to you, what you want to be configurable ;)
<sri> alternative loggers would most likely just be plugins
<sri> don't try to solve problems you don't have :)

<tempire> Does mojolicious provide a way to modify the mojolicious::controller class?  Say, if I wanted to add a ->model method to be accessible to all controllers without creating an intermediary subclass of m::c.  
<tempire> I suspect you'll say that's a very catalyst-y way of thinking.
<sri> app->controller_class('MyController::Lalalala');
<tempire> So, in using, ->controller_class('MyController::Lalalala');, all controllers that have "use base 'Mojolicious::Controller'" will have access to methods in "MyController::Lalalala" ?
<sri> tempire: nope, it will be the default cotroller class for all Mojolicious::Lite actions
<sri> tempire: all controllers would still have to inherit from it
<tempire> ah
<tempire> that makes more sense
<sri> automatically changing all base classes would be quite bad ;p
<sri> tempire: usually for app wide models it makes mroe sense to keep their instances in MyApp.pm
<sri> they can be accessed from controllers via $self->app->...
<sri> controllers are per request only, so not persistent
<tempire> That's what I was thinking, but I'm thinking in terms of database connections
<tempire> Where I want to connect and disconnect on every request
<tempire> Which, now that I say that, it makes sense to make a plugin

<tempire> I'm using a bridge to execute a sub before all other actions; how do I do the opposite? As in, "sub request_has_ended" ?
<sri> tempire: there is no routes way but a plugin hook
<sri> or you could overload process in MyApp
<sri> if it's for a model thingy again, making it a plugin might be a good idea
<sri> tempire: Mojolicious::Plugin::RequestTimer shows how to do something before and after processing a request

Writing files
<doubi> Evening all. I want to persist some data for my app in a plain text file (for now). The module that first caught my eye was Asset::File, but I couldn't understand why it wouldn't create a new file. Looking at bootylicious, it looks like what I really want are the functions provided by Mojo::Command. Am I on the right track now? Does Asset::File just simplify some things about reading and writing data?
<tempire> doubi: Mojo::Asset::File creates a file for me without a problem.  http://showmetheco.de/713a3ad1975a29a4b03cf82004b0043f5f2047a6

  use Mojo::Asset::File; 
  my $asset = Mojo::Asset::File->new(path => '/tmp/mojo.txt');
  $asset->add_chunk('foo bar baz');
  print $asset->slurp;

<sri> The main job of Mojo::Asset::File is to take care of uploads and the like behind the scenes
<sri> it's not a general purpose file api
<sri> just use IO::File :)
<sri> don't use Mojo::Asset
<sri> it's for internal use, not a general purpose file api
<doubi> Ah, ok. So if I want to work with files to save stuff from my app, should I be using ::Command? Or just whatever module off cpan?
<sri> not command
<sri> IO::File or whatever
<sri> we don't have a general purpose file api in mojo

<xantus[]> I'm updating the websocket examples
<xantus[]> with a jabber client!
<sri> Oo
<xantus[]> Should I just do the irc client first
<xantus[]> that wouldn't require a user/pass
<xantus[]> yeah
<esskar_> sri: what env var do i have to set to see what mojo::client sends?
<esskar_> i'd like to see the actually requests
<xantus[]> I usuall use ngrep
* sri uses ngrep too
<xantus[]> sudo ngrep -W byline port 80    (for outgoing)
<xantus[]> you might want to also specify host
 http://github.com/xantus/mojo-websocket-examples/blob/master/script/websocket-irc-example-1
<sri> wow, cool idea
<sri> reusing mojolicious as a websocket to socket gateway
<xantus[]> sri: maybe you can help me figure out why error_cb isn't called on disconnect
<sri> hup_cb?
<xantus[]> oooh :)
<xantus[]> lol
<sri> so far i thought protocols like irc would be handled server side, but this makes so much sense
<sri> you get authentication and then keep all load off the servers
<xantus[]> http://xant.us/ext-ux/lib/Sprocket/Filter/IRC.js
<xantus[]> http://xant.us/ext-ux/lib/Sprocket/Filter.js
<xantus[]> POE data filters ported to js
<sri> :o
<xantus[]> here are the rest http://xant.us/ext-ux/lib/Sprocket/Filter/
<xantus[]> its stackable
<xantus[]> put a line filter and a json filter together: lines of json in, objects out
<xantus[]> objects in, lines of json out
<xantus[]> I used it with sprocket socket
<xantus[]> the long polling socket proxy
<sri> aww...you used app->start
<sri> how conformist of you
<sri> ;p
<sri> really beautyful though
<sri> xantus[]: you totally need to blog that
<sri> and i'll push you until you do :)
<xantus[]> lol
<xantus[]> its ugly
<xantus[]> I should wrap it with ext in a window, and blog it
<xantus[]> I still have my irc client in ext
<sri> do it!

 client_close()
<sri> oh, those are state machine methods, DON'T TOUCH THEM!
<sri> you call ->finish
<yko> oops.
<sri> that will do the right thing
<yko> thx... btw, server_close == client_close for ws :p
<sri> everything prefixed with server_ or client_ is dangerous

(12:50:37 AM) vti: sri: ye, i am sure this can be somehow simplified:

#!/usr/bin/perl

use Mojo::Client;
use Mojo::Transaction::HTTP;

my $url     = shift @ARGV;
my $handler = 'mpg123 -';

open(HANDLER, "|$handler") or die "Cannot pipe input to $handler: $!\n";

my $tx = Mojo::Transaction::HTTP->new;
$tx->req->method('GET');
$tx->req->url->parse($url);
$tx->res->body(
    sub {
        my ($res, $chunk) = @_;
        print HANDLER $chunk;
    }
);

Mojo::Client->new->process($tx);

close HANDLER;

(12:51:59 AM) sri: my $tx = $client->build_tx(GET => $url); $tx->res->body(sub {...}); $client->process($tx);

10:21	yko	and reusable template blocks also looks attractive
10:24		As i understand, once defined content block would not be overriden by 'content "foo" => "bar"' , is it correct?
10:25	sri	yes
10:25		that way the first one defined wins, which makes inheritance work

14:36	yko	$app->defaults! That what i need, but did not found before
14:36		like $app->defaults(layout => 'main');
14:41		garfield joined #mojo
14:44	sri	it's new
14:44		discovered i need it for the guide :)

GitHub91	mojo: 07master 03Sebastian Riedel * 3c6e4e8 (9 files in 6 dirs): added finished callback support for HTTP transactions - http://bit.ly/deTDF3
18:34	sri	btw. the finished callback can now be used to delay cleanup stuff until after the response has been sent to the user

09:24	tab	where can i store a database schema handler create in the startup method to access it from controllers?
09:25	dotan	tab: in your app, which is accessible from your controller as $self->app
09:25		(the app is the class with the startup method)
09:28	tab	ah thanks, it works

13:18	tab	where should i define a helper sub to use in the ep-templates? e.g. for formatting currency values
13:19	sri	tab: see rendering guide
13:25	ysyrota	sri: is it possible to specify layout in inherited (extended) template?
13:26	sri	ysyrota: yes
13:27		extend and layout are almost the same
13:27		i think i mention it in the rendering guide too
13:28	ysyrota	sri: how? if I simply specify "% layout 'something'" in extended template, it doesn't work, but if I specify this in base template then it will work
13:29	sri	ysyrota: umm, you mean extending template then
13:29		thats not possible of course

13:32	yko	another stupid question: how do i append something to url's path? path->append('foo/bar') does escaping... :(
13:33	sri	yko: push the elements on ->parts
13:33	yko	thx
13:36		push (@{$url->path->parts}, @{Mojo::Path->new('foo/bar')->parts});
13:36		ugh...
13:37		well, actually $url->path->append( @{Mojo::Path->new('foo/bar')->parts} )
13:38	sri	yko: why would you do that?
13:38		wait...
13:39		you have a url object!
13:39	yko	shure
13:39	sri	$url->path('foo/bar')
13:39		the same ;p
13:39		we now append relative paths

20:14	sri	well, plugging any existing irc bot into mojo should be trivial
20:15	sri	Mojo::IOLoop->singleton->tick_cb(sub {POE::Kernel->run_one_timeslice})

die -> simply throws an exception, logging as an error.

17:36	crab	what's the right place to open a database connection in a mojolicious app? i looked at mojo-paste and it opens a new one each time in sub process
17:36		before calling ->dispatch. i could do that, but i'd like to reuse the handle if possible. so is there a better place?
17:37	sri	app->defaults(db =>...)	(if you're using lite)
17:37	will put the handle into the stash on every request, but instantiate it at startup
17:38	crab 	i was using lite, but i'm switching to non-lite now
17:38	sri	then it's $self->defaults(...) in your startup sub

Using DB: if you're using something that preforks you'll be ok	http://github.com/yko/Mojolicious-Plugin-Db that plugin :p	 http://pastebin.com/iazBrG3J that's little init example and there's http://bit.ly/aE9Adk usage example
        even better: just init connection to db in your startup { }	and then place it into defaults;	look in cometdesktop	http://github.com/xantus/comet[…]p/CometDesktop.pm
        $self->default(db => $dbh);
        also lots of juicy stuff in comet-desktop	like multiconfig plugin	and multiple static fallback	you can have overlaying paths
        where one can take precedence over the other

static binary files in <DATA>:	xantus: where's the code that does this static base64 thing?
xantus:	just do the normal make and make install walk
        you can create base64 blocks uing a program called recode
        recode ../b64 <file.jpg >>myscript.pl
        that'll append the base64 to the bottom, after you've added @@ file.jpg;base64

to force logs to stderr:
crab:    btw, how can i make ./foo daemon print logs to stdout with a mojolicious app the way it does with m::lite?	crab: log->path(undef)

requst timeouts:
MojoGuest497	how to set timeout on method get?

07:01	marcus	MojoGuest497: I think you have to set connection_timeout on the Mojo::IOLoop object	$client->ioloop->connection_timeout()

07:02	sri	$client->keep_alive_timeout is equal to that right now
=end comments

route gotchas:
08:41	xantus__	I can't match / with /(*foo)
08:44	so I have to add a / route :/

08:49	sri	use a custom regex
08:49	(*foo) is qr/(.+)/
08:50	'/(*foo)', foo => qr/.*/
08:52	not sure if thats counter intuitive
09:08  	dynax60	get '/search/:cid' => [ cid => qr/\d+$/ ] => \&search => 'search';	for example :)

ghithub stuff:
18:19	tempire	What's the best way to update a previously forked repo on github?

18:27	usually i do git pull --rebase origin master; git push -f own master	where own is my fork
18:28	there was perfect article about forking on github

18:28	tempire 	I just found one	git remote add upstream http://github.com/kraih/mojo.git, then git fetch upstream	log doesn't update, though.
19:04	sri	tempire: you should rebase, merging makes it harder for me

hmm:
       $self->match->stack is neat?

async:
17:37	und3f	I am trying to build simple async app with mojo client wich must run async if Mojo server present and blocking otherwise. I got next code http://pastebin.ca/1913934 it works perfect with Mojo server, but if i run it from clean app it just load CPU and do nothing
17:39	sri:
(kvorg:	should really really testa and uderstand this - from  t/mojo/client.t :)

package TestTest;
 
use strict;
use warnings;
 
use base 'Mojo::Base';
 
use Mojo::Client;
use Mojo::IOLoop;
 
sub request {
    my ($self) = @_;
 
    my $client = Mojo::Client->singleton;
    my $stop_server = ! Mojo::IOLoop->singleton->is_running;
    $client->async->get(
        'http://google.com/',
        sub {
            my ($self, $tx) = @_;
            print "Got google!\n";
            $client->async->get(
                'http://localhost:8080',
                sub {
                    my ($self, $tx) = @_;
                    warn $tx->res->body;
                    $client->async->ioloop->stop if $stop_server;
            })->process,
    })->process;
    $client->async->ioloop->start;
    print "here\n";
}
1;

14:12	tom	question: if I have a callback in $client->get($url,$cb); And I need to do other get requests inside the callback, is it best do create a new client instance or reuse the existing $client ?
14:12	sri	tom: do you want to process those requests blocking?
14:13	tom	the once inside the $client callback yes
14:13	sri	just reuse the client, it will clone a new one automatically
14:14	tom	so it doesn mather that the existing client is async? if it clones a new one it become sync/blocking.
14:14	sri	oh
14:14		that does matter
14:15		then you need a new one

How to execute as a CGI script (... add others):	PATH_INFO=/foo ./myapp.pl

perl -MMojo::URL -le'my $u=Mojo::URL->new("http://localhost:3000");$u->query->param(foo=>[qw/bar baz/]); print $u;

08:25	dynax60	guys, how to make json-request on remote server? have you some sample?	on remote server side I must get it by:
my $request = $self->req->json || return $self->render_json( { 'status' => 'Request error' } );
08:28	sri	then it's wrong	sri	$client->post("http://80.76.224.24:3000/arping", {'Content-Type' => 'application/json'}, $json);	perl -MMojo::Client -e 'Mojo::Client->new->post("http://80.76.224.24:3000/arping", {"Content-Type" => "application/json"}, $json);'
08:34	dynax60	and as a result I will have smth in $self->req->json on server side, right?
08:34	sri	are you still using post_from instead of post?	thats where the error is coming from	post_form is really just for urlencoded and multipart/form-data	as in submitted html forms

using Template Toolkit instead of ep:

06:07   geekus	I'm trying to convert a set of EPL templates to TT
06:08	I have things like $self->{stash}->{foo} and $self->req->params('xyz') in my EPL
06:08	I'm not too familiar with TT... if I don't modify the controller at all, how can I get at these same things in TT with Mojo
06:09	will self be passed into the TT for vars?
06:09		so do I say self.stash.foo
06:15		CPAN page for MojoX::Renderer::TT says "Template parameter are taken from  $c-stash >." but that's a typo
06:15   	are there examples anywhere using TT templates?
06:20	sri	[% c.stash %] i guess
06:22	geekus	but what is "c"
06:22		is $c the $self
06:32	geekus	yes c.req.param('foo') works and so does c.stash.foo
06:39	geekus	and in a layout you think I just do [% c.render_inner %]
06:40	sri	with the latest cpan version you might also be able to use helpers like [% h.content %]

working with mojo server daemons:

08:13	dynax60	sri, what to do if we need the build-in web-server to make it daemonized
08:15	sri	daemonizing is not portable, so daemon can't support it
08:15		daemon_prefork is unix specific, so it can
08:16		daemon is supposed to be able to run everywhere perl can :)
08:25		daemon_prefork is pretty much always better for deployment
08:26		it scales with cpus, and workers get restarted after 1000 requests
08:26		and and and :)
08:26		with --clients 10 you can also make workers go async
08:27		giving you a pool for normal async daemons
08:28	vti	async async!

stash modification from one template to another (including, layouts):

08:37	esskar	moin

finishing with requests or going async:
02:46	tempire	that's true.  I'm just bitter because I had to sit and figure out what was going on.
02:46	sri	you can also just use render
02:47		$self->render(data => '', status => 403) or so
02:47		thats imo the correct way to handle it
02:49		we now simply assume that people signal that they are done by calling ->rendered, ->render, redirect_to...or any of the other response generators
02:51		btw. if the check passes i don't think you should do anything besides returning true
02:52		200 will be take care of by the renderer
03:00		btw. the most important async case for me is client requests
03:00		http://github.com/kraih/mojo/b[…]s/lite_app.t#L364
03:01		this is where the new design shines
03:01		you can just fire off async client requests and render later in the callback
03:02		it will just work
03:03	tempire	Still within the timeframe of the original request, though, right?
03:04	sri	no response gets sent before it is rendered
03:04		it just waits and handles other requests in the meantime
03:05	tempire	ah, so that process isn't locked
03:05	sri	ye
03:06	sri	it makes latency not matter much
03:07		especially if you're querying couchdb for example
03:09		and if the environment doesn't support non blocking (like CGI) it will simply fallback to blocking

include in ep:
08:37 esskar	about the include feature in ep:
08:37		when I set a variable inside the included template
08:37		it is not set outside the template
08:47	esskar	i put $self->stash(picture => undef)
08:48	sri	you can set the stash value though
09:01	esskar	sri: is <%= include 'foo', picture => \$picture %>" working?
09:01	sri	sure
09:02		picture will be localized though and not available outside
08:47		then i set $picture inside the included template

09:28	ysyrota	sri: I get error Mojolicious::Plugin::EplRenderer:70 [9797]: Template error in "m0.html.ep": Route "
" used in url_for does not exist
09:35	ysyrota	sri: the templates contains only one string: <% content 'm0' => url_for %>
09:35	sri	where is the ;?
09:36		that will get compiled to something unpredictable
09:36		url_for;

lesser known helpers:
<% app->mode %> to get at app

DB handles 2010-08-15:
18:51	crab	sri/yko: i know i've discussed this before, but opening db handles in startup() as suggested seems to not be the right thing to do
18:52	sri	crab: why not?
18:52	crab	because it creates one dbh before forking and all the children share it.
18:52	sri	$self->defaults(db => $handle);
18:52		ah
18:53		right, that would require lazy loading
18:53	sri	like an attribute on the app class
18:54		__PACKAGE__->attr(db => sub {...}); ... my $db = $self->app->db;
18:54	crab	where are attrbutes documented, or alternatively is there some example i can look at?
18:54		ah, perfect.
18:54	sri	normal perl oo
18:55	alternatively you could use a plugin hook
18:56		app->plugins->add_hook(before_dispatch => sub { $_[1]->stash->{db} = $handle });
18:56	crab	i think the attr works for me, once the sub returns a value it's cached for me and returned, right?
18:56	sri	right
18:56	crab	perfect
18:57	sri	it's an interesting problem though, maybe there's a way for us to handle it better
18:57	vti	or use dbix::connector
19:00	sri	oh, dbix::connector is a good idea
19:00		crab: just do startup and dbix::connector
19:01		seems way more elegant
19:03		automatic fork handling
08:15	marcus	omega: in startup, you can typically do stuff like $self->defaults( model => MyModel->new(..) );
08:16		omega: and $self->stash->{model} will be available in every request.

09:38	crab	what happens if i say <%= content 'blah' %> and there is no blah defined
09:39	yko	i don't remember if there's fixup for undef
09:39		usually i just do <%== content('blah') || '' %>

14:10	yko	how to bring Mojolicious logs to console? app->log->path(undef) ?
14:11	sri	no log directory is enough
14:22	sri	app->log->handle(\*STDERR) might work

More JSON:
16:38	maettu	I POST a JSON-Object to mojolicious by a qooxdoo application. I can see in the mojo-server-console that the request comes in, but how can I access the JSON object / where is it?
16:39	sri	maettu: the json object is the body?
16:39	maettu	dunno
16:40	sri	do you want it encoded or decoded?
16:40	maettu	sri: decoded
16:40	sri	my $object = $self->req->json
16:40		that might just work
16:43	maettu	sri: Use of uninitialized value $object in print at.. :-(
16:44	sri	then it's likely more complicated, possibly urlencoded
16:45		then you'll have to get the encoded json via ->param and decode it yourself with Mojo::JSON
16:46	sri	you can print $self->req to get a picture of what you're dealing with
16:46		yes, but thats a huge structure to dump
16:47		content type would be a good hint i guess

 ssl:
19:59	vti	maettu: for debian/ubuntu libio-socket-ssl-perl is enough, it will download needable packages

Serving static files:
20:56		ahhh, me again: how can I ask Mojolicious to serve file "../source/Application.js" on "/whatever"?
20:58	yko	static files are supposed to be in 'public' actually
20:59	xantus	app->static->serve( $self, $path ); # relative to public
20:59		app->home->rel_dir( 'public' ); # setting public dir, relative to home
20:59	sri	or just "ln -s" for specific files
20:59	xantus	er no
20:59	sri	(into public)
20:59	xantus	thats fetching public path relative from home
21:00	yko	or change  $c->app->static->root('your/source');
21:00		$c->render_static($path);  and then change $c->app->static->root back :D
21:00	xantus	app->static->root( '/whatever' );
21:00	yko	*not sure if it works
21:00	sri	or just throw all your stuff into public
21:05	maettu	ehm, statically delivering a .js file shows the listing in the Browser..
21:25	maettu	ok, thanks, but it doesn't work
21:25	sri	it's a relative path
21:25		relative to your public directory
21:26	yko	there's restriction that does'nt allows somebody to get ../../../../../etc/passwd or something like that i think
21:26	maettu	Can't locate object method "app" via package
21:27	yko	app? where do you call it? and on which object?
21:28	maettu	on the object of the app itself
21:29		I call it in script/[my_app].pm
21:29		in sub startup{}
21:31	yko	ohh... so. let me introduce you structure of Mojolicious internal objects
21:31		controller has accessor app - that represents 'application' object
21:31		so for access application in controller you need to call $c->app->something....
21:32		if you are in startup { } you already have aplpication object- your $self
21:32		so you should call $self->method instead of $self->app->method
21:32		that is one more reason why i use $c/$app instead of $self in both cases.
21:57	maettu	successfully served static pages outside public :-)

understanding the traffic:
 sudo ngrep -d eth0 host irclog.perlgeek.de and port 80

custom headers:
16:34	vti	hm... can i set custom headers when using get_ok? apparently not... hm
16:34	sri	of course
16:35	vti	reallY?
16:35	sri	get_ok(..., {...})
16:35		i do that all the time for lite_app.t

modes and log levels:
16:39	sri	the question is should we promote MOJO_MODE or simply add a --loglevel command line switch
16:39		(for lite)
16:40		for lite all the mode does is pick a log file with the mode name and the right log level
16:42		the "app->log->level('error');" trick is also shown in the tutorial
16:42		to make apps less noisy
11:07	yko	wow
11:07		$self->$mode(@_) if $self->can($mode);
11:07		i haven't seen that
11:07		so if application can 'development_mode' it will be called at startup?
11:08		before startup, even
11:08	sri	just liek the pod says ;p
11:08	yko	how sweet, thank you
11:09	sri	it's the big advantage normal mojolicious has over lite regarding modes
11:10	vti	yko: you didn't know about that? OO
11:10		http://github.com/vti/mojolici[…]ojoliciousApps.pm
11:10		here is an example how to use it :)

examples: bootylicious, pastelicious, urlicious, contenticious
mojowka and mojomber!


ajax with mojolicious: http://github.com/yko/mojolicious-example-ajax/commits/master/

fastcgi with sockets:
15:19	skaurus	trying to start Mojo in fastcgi mode with socket:
15:19		script/birdy fastcgi --listen file:///tmp/birdy.sock
15:19		and receiving: Can't accept FastCGI connection: Socket operation on non-socket
15:20		ls -Fla /tmp/birdy.sock: srwxrwxrwx 1 root root 0 Aug 22 11:07 /tmp/birdy.sock=
15:20		daemon mode with this socket seems to start
15:20	sri	the native fastcgi binding doesn't support listening on sockets
15:21		it requires and external proc manager
15:21		spawn-fcgi is the most popular i think
15:22	sri	you can always get a list of all available options for a command with "mojolicious help $command"
15:23		in the case of fastcgi, there are no options :)
15:25		or you could use PSGI, there is a cookbook recipe
15:25		"% plackup ./script/myapp -s FCGI -l /tmp/myapp.sock"
15:26		from what i heard spawn-fcgi is more fun though
15:30	sri	the cookbook lists quite a few deployment options, my favorite is the prefork daemon behind a nginx reverse proxy

logs and deployment:
16:14	dotan	does mojolicious write a log file by default when run as Fastcgi? Does it try to create it under $Findbin::bin/log or similar?
16:16		OOh! It writes to the Apache log, of course!

remote server address:
21:16	tab	hi, what is the best way to get the remote ip address of the client using my Mojolicious application?
21:16		currently I´m using the prefork daemon together with nginx, where $ENV{REMOTE_ADDR} doesn´t work
21:17	sri	don't use %ENV in mojolicious
21:18		$self->tx->remote_address;
21:18	skaurus	proxy_set_header X-Forwarded-for $remote_addr; ?
21:18	sri	you might have to enable MOJO_REVERSE_PROXY=1
21:19		depends if nginx is on the same server
21:20		it of course depends on X-Forwarded-For
21:22	tab	nginx is on the same server
21:30		now $self->tx->remote_address returns 127.0.0.1  :-(
21:30		but MOJO_REVERSE_PROXY is set to 1
21:35	sri	then X-Forwarded-For is missing
21:35	tab	now it works
21:36		i added this x-forwarded in nginx config
19:57	sri	proxy_set_header Host $http_host;
19:17	DaTa	marcus: ProxyPreserveHost On
19:17		for apache :)
21:03	sri	dumping $self->req->env usually shows whats wrong
--> see cookbook

rendering data:
20:46	stephan48	how do i prevent encoding of text via mojo?
20:46	sri	use data
20:47		text = perl chars, data = perl bytes
20:47	stephan48	how to accomplish that?
20:47	skaurus		render(data => ...)

18:38	crab	can i override the built-in TagHelpers?
18:40		if i do $app->renderer->add_helper(input => ...), will it do the right thing?
18:41	sri	it will

using deparse
perl -MO=Deparse -e 'use constant DEBUG => 0; print "FOO!" if DEBUG; print "BAR!"'

user ids
21:39	ash_	is there a way to get to the session id with mojo?
21:39	sri	what session id?
21:40		by default there is none
21:41	ash_	hmm, i wonder what the best way of coming up with a guid for each session is... i was just hoping it already did that :P
21:41	sri	none needed for sessions
21:42	ash_	yes, well, i have a need for a guid for each session for another piece of software
21:42	sri	generally sha1(username + time + rand) is quite good

getting current request method
05:22	polvo	how do i get current request method from a controller?
05:27	koban	polvo: $self->req->... in your controller
01:04	sri	*all* information about a request is available
01:05		with print $self->req you can even let mojolicious rebuild the request

controler and variables:
22:29	skaurus	and one more question... is there a place where i can populate Controller object with some my variables?
22:30	sri	use the stash
22:30	skaurus	i can call some func inside each method and populate $self with anything
22:30		but maybe some central place?
22:30		like "before"?
22:31	sri	well, it's just a perl object
22:31		you can always overload new
22:31	skaurus	nice idea, thanks :)
22:33	tempire	skaurus: You might be wanting a routing bridge.
22:33	sri	or just app->defaults(...)
22:34	skaurus	tempire: what is a "routing bridge"?
22:34	tempire	Mojolicious::Guides::Routing
22:34	sri	it's all in the guides
22:34	tempire	under the heading, 'ADVANCED'

--reload blues
If reloading does not seem to work for your, your source probably has fatal syntax errors. Try perl -c on the files changed.

flash:
00:20	diegok	if I put $self->flash( xx => 'lalala' ), I'll have flash->{xx} on the next request (after redirect_to) .ep on <% flash->{xx} %> ?
00:34		I'm always getting flash = {}...
00:35		but I can see the value on session->{old_flash}{xx}
00:46	sri	diegok: <%= flash 'xx' %>
00:47	sri	hash access is set only
00:48	diegok	so, I can check to have a value with ----> % if ( flash 'xx' ) {
00:50	diegok	thank you ;)
00:52	sri	flash is special, because old values come from a different hash

redirects:
15:54	xantus_	sri: how do you feel about making redirects easier
15:54		for example: get '/' => '/index.html';
15:56	sri	that case is reserved for route names
15:56	xantus_	no biggie, get '/' => sub { shift->redirect_to('/index.html'); }; is not too hard either
15:56	sri	was about to say it :)
15:58	xantus_	oh, is there a mech for internal redirect?
15:58	sri	we don't do internal redirect, bad design
16:00	xantus_	$c->render_static is what I really needed anyway

nested controllers (or subnamespaces)
17:23	nuclon	is there a way to have nested controllers, like 'admin', 'admin/users' => App::Admin, App::Admin::Users?
17:24	sri	admin-users
17:25		route('/admin/users')->to('admin-users#list') or so

static files and binary files in __DATA__:
16:42	ash_	can you configure a mojo lite app to server static files?
16:47	sri	ash_: no need to configure, it automatically serves static files from the public directory
16:48	ash_	do you have to set it? i keep getting errors (this is a lite app with everything in 1 file currently)
16:49	sri	you of course need a public directory with static files
16:50		or do you want to serve static files from the DATA section?
16:50		thats possible too if they have the right name
16:51		like @@ static.txt
16:51	ash_	so, if i had /file.pl then /public/images/logo.gif is that how i need to setup my directories?
16:51	sri	yes
16:51	ash_	i have the text based stuff in the DATA section, i just was wondering more for images
16:51	sri	@@ static2.png (base64)
16:51		:)
16:51		we also support inlined base64 files
16:53	ash_	do you know an easy way to base64 a file?
16:53	sri	Mojo::ByteStream makes it simple once you have the file in memor16:53		hmm, wonder if we should add a command :)
16:54		"mojo base64 foo.png" could be useful
16:55	ash_	"mojo base64 foo.png >> myfile.pl" and get @@ foo.png + base64
16:55	sri	hmm, openssl does base64 too
18:06	sri	"openssl base64 -in foo.png"

06:04		could anyone tell me how to render json response for using jsonp (with callback function)?
06:05		i.e. request from JQuery will be smth like: http://url/?foo=bar&callback=test
06:06		It must be in response body: test({"key":"val"})
06:10	sri	$self->render(data => $json, format => 'json');
06:11		or actually format => 'js' i guess
06:11		we don't have a special helper for jsonp
06:11		you just use Mojo::JSON to encode your structure and add a wrapper yourself
06:13		my $json = $self->render(json => {key => 'val'}, partial => 1); $self->render(data => "test($json)", format => 'js');
06:13		something like that

controller namespace:
03:22	Kulag	Is it possible to get Mojolicious to detect my controllers if they're under AppName::Controller:: instead of AppName::?
03:24	crab	$r->namespace('AppName::Controller');
03:30	crab	read Guides/Routing.pod

always decode data from DBI:
16:42	sri	ah, seems to be DBD specific
16:42		my $dbh = DBI->connect($dsn, "root", "", { mysql_enable_utf8 => 1 });
16:43		pg_enable_utf8 for postgres

timed events:
03:37	sri	with the daemon it's possible Mojo::IOLoop->singleton->timer(...)

cache helper:
the cache helper runs the code once, caches its result as a string in the compiled template, and just uses the string. Then the life time of the cache is the lifetime of the server - one request for CGI, but much much longer for Daemon-Prefork (ie Hypnotoad), FastCGI and Pluckup/ModPerl? And the cost in the CGI case is negligible.

extends and layouts:
08:11	koban	sri: can i  'extends' template that uses 'layout'?
08:12	sri    		one of the two
08:13		they are exclusive i think
08:13	koban	so or layout or extends?

routes from plugins:
10:06	maettu	what I don't understand about the plugin system is how I can write a plugin that acts like a route.
10:07		everything I find are events that happen before or after a dispatch
10:11	sri	maettu: your plugins register normal routes
10:11		maettu: there's an example in the guides
10:12		the register method of your plugin gets the $app instance
10:12		so you get $app->routes
10:12		you can do *everything* startup can

error page from a plugin and from a renderer:
just use die()
09:28	zakame 	sri: thanks :) so as for my renderer trying to handle bad input, what should I do?
09:46	sri	zakame: depends what you want to do, generally $c->render_exception(...) might be a good idea

17:06	nuclon	does Mojo::Message::Request have an method for getting user ip address?
17:08	sri 	nuclon: $self->tx->remote_address or so

13:30	sri	get '/happy' => '*';
13:30		(will render the template happy.html.ep)
13:32		or just get '/happy' => sub { shift->render('happy') };

minimalistic path rewrite in a plugin:
app->plugins->add_hook(before_dispatch => sub {
    my ($self, $c) = @_;
    return unless my $rm = $c->param('rm');
    $c->req->url->path($rm);
});

full page caching:
18:17	sri	not sure i actually want full page caching inside mojolicious
18:18		setting the appropriate headers and letting an nginx take care of caching is generally way better
18:18		(for full page)

params and stash:
20:01	esskar_	agreed

20:03		$c->param does not read anything from stash, does it?
20:03		oh, it does
20:03		thats evil
20:04	marcus	$c?
20:04	esskar_	$c as in $self
20:04		as in controller
20:05	marcus	$celf
20:05	esskar_	i thought it's just s shortcut to $self->req->param
20:48	xantus[]	wait, $c->param reads from the stash?
21:00	marcus	my $params = $self->stash->{'mojo.params'} || $self->req->params;
21:01		so that routes can add to them, apparently
21:07	esskar_	whats {'mojo.params'}?
21:08	marcus	it's a clone of the params
21:08		my $p = $c->stash->{'mojo.params'} ||= $c->tx->req->params->clone;
21:53	sri	esskar: not the whole stash
21:53		$self->param is $self->req->param + route captures
21:53		only captured values, not the whole stash

uploading files:
(06:50:03 PM) und3f: sri, btw, does $client->post( $url, file => {content => $content } ) uploads a file?
(06:50:34 PM) sri: that request looks wrong
(06:51:39 PM) sri: there is no way that produces a sensible request
(06:51:46 PM) und3f:            my $tx= $client->post_form(
(06:51:46 PM) und3f:                'http://kraih.com/foo',
(06:51:46 PM) und3f:                {file => {content => 'lalala'}}
(06:51:46 PM) und3f:            );
(06:51:56 PM) sri: ...
(06:52:04 PM) und3f: oh right
(06:52:11 PM) und3f: i missed just 2 brackets 
(06:52:18 PM) sri: and the method
(06:52:56 PM) und3f: sri, let me rephrase question
(06:53:20 PM) sri: if you want to know what i actually produces try print $client->build_form_tx(...)->req;
(06:53:39 PM) sri: takes the same arguments
(06:53:40 PM) und3f: thanks
(09:44:40 PM) und3f: sri, how to check that upload limit were exceeded?
(09:45:25 PM) sri: req->error

23:20	esskar_	is there a property to the template path somehwere?
23:30	sri    	$app->renderer->root?

on partial rendering:
15:30	esskar_	sri, if i have file to a template, how can i render it to a string with all the stuff from the stash accessible from the template?
15:31	und3f	esskar, $self->render_partial
15:38	esskar_	und3f: even if i only have the filename? or what do i put as the first parameter?
15:39	und3f	esskar_, rednder_partial uses same arguments as render
15:40		esskar_,  you can do $self->render_partial(template => 'test');

(12:54:13 AM) stereonaut: Hello folks. What should I be using to serve static files through actions on controllers? Upon request, I need to run some logic to serve an specific static file.
(12:56:37 AM) DaTa: stereonaut: $c->render_static('images/logo.png');
(01:07:49 AM) stereonaut: DaTa: thanks.

05:37:17 AM) polvo: heh. the manual says 'just make sure not to use ^, $ and ()' for placeholder checks. then how do i workaround qr/(white|black)/ ?
(06:05:31 AM) sri: polvo: qr/white|black/ should just work
(06:05:55 AM) sri: you can always look at the compiled regex via "myapp.pl routes"

(09:16:18 AM) yakudzo: can anyone tell how to add Mojo::Log to helper to use it like $self->log->info('some thing')
(09:26:55 AM) koban: yakudzo: $self->app->add_helper(log => sub { shift->app->log->debug( @_ ) });
(09:27:33 AM) yakudzo: koban, in sub statup ?
(09:35:20 AM) yakudzo: koban, in sub startup it is $self->addhe_lper. 

cookies in requests:
09:08	zamolxes	hey. i'm trying to make a http request with a cookie, not quite sure how to do that, i got the cookie jar, what do I pass to ->add ?a  Mojo::Cookie?
09:17		worked
09:18	Rhaen	:) what worked?
09:18	zamolxes	$client->cookie_jar->add(Mojo::Cooki​e::Response->new(domain=>'foo.com', name=>'wutwut', value=>'but')); $client->get('foo.com/wutwut'); #works

=cut
1
